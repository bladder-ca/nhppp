[{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"simulation-description","dir":"Articles","previous_headings":"","what":"Simulation description","title":"Sampling log-linear times","text":"Assume population K=105K = 10^{5} individuals indexed k∈[K]:={1,…,K}k \\[K] := \\{ 1, \\dots, K\\}. person kk, want simulate first occurrence event (e.g., emergence tumor) age (time) interval [Tk0,Tk1)[T_{k0}, T_{k1}). example, Tk0T_{k0} may age years person kk enters simulation, Tk1T_{k1} age years person dies non-cancer causes. (practice, Tk1T_{k1} obtained separate point process.) people develop clinical cancer simulated lifetime. fix simulation scenario, let ak=40a_k = 40 kk bk∼U(50,100)b_k \\sim U(50 , 100), U()U() uniform distribution. use log-linear intensity function λk(t)=eαk+βkt\\lambda_k(t) = e^{\\alpha_k + \\beta_k t}, tt age years. parameters αk,βk\\alpha_k, \\beta_k random individuals population αk∼N(−4,0.5)\\alpha_k \\sim N(-4, 0.5), βk∼N0+(0.03,0.003)\\beta_k \\sim N_{0+}(0.03, 0.003), N()N() normal distribution N0+()N_{0+}() truncated normal distribution support [0,∞)[0, \\infty).","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"overview-of-sampling-methods-described-here","dir":"Articles","previous_headings":"","what":"Overview of sampling methods described here","title":"Sampling log-linear times","text":"use three methods: Simulate one person time looping persons. fastest way use special case function nhppp package samples log-linear intensity functions non-vectorized fashion. Yet slowest approach. Simulate persons vectorized way using intensity function λ(t)\\lambda(t). know λ(t)\\lambda(t)nhppp uses thinning algorithm. flexible approach require lot information – just λ(t)\\lambda(t). much faster first option, fast third option. Simulate persons vectorized way using cumulative intensity function Λ(t)\\Lambda(t) inverse Λ−1(z)\\Lambda^{-1}(z), defined . analytic expressions objects, get fastest sampling nhppp package. package can use inversion order statistics algorithms efficient.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Sampling log-linear times","text":"use data.tables – analysis obvious base R. use functions three packages, without loading : truncnorm package needed truncated normal distribution. tictoc() package used simple time comparison different ways one can simulate problem. stats package used generate normally uniformly distributed samples. Setup pop, population data.table. person specific parameters αk,βk,Tk0\\alpha_k, \\beta_k, T_{k0} Tk1T_{k1} variables pop.","code":"library(data.table) library(nhppp) pop <- setDT(   list(     id = 1:K,     alpha = stats::rnorm(n = K, mean = -4, sd = 0.5),     beta = truncnorm::rtruncnorm(n = K, mean = 0.03, sd = 0.003, a = 0, b = Inf),     T0 = rep(40, K),     T1 = stats::runif(n = K, min = 50, max = 100)   ) ) setindex(pop, id) pop #> Index: <id> #>             id     alpha       beta    T0       T1 #>          <int>     <num>      <num> <num>    <num> #>      1:      1 -4.318439 0.02914304    40 74.23810 #>      2:      2 -4.200092 0.03218084    40 62.26187 #>      3:      3 -4.250369 0.02916144    40 81.29045 #>      4:      4 -4.374602 0.02269157    40 94.50129 #>      5:      5 -4.075769 0.02973159    40 67.73704 #>     ---                                            #>  99996:  99996 -4.113622 0.03196925    40 71.34211 #>  99997:  99997 -5.111481 0.02665030    40 84.46180 #>  99998:  99998 -3.628798 0.02907565    40 87.67655 #>  99999:  99999 -4.438333 0.03027740    40 99.96851 #> 100000: 100000 -3.483592 0.02673899    40 57.45794"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"intensity-cumulative-intensity-and-inverse-cumulative-intensity-functions","dir":"Articles","previous_headings":"Setup","what":"Intensity, cumulative intensity, and inverse cumulative intensity functions","title":"Sampling log-linear times","text":"Define bespoke functions different simulation approaches . trick define functions work vectorized form. example, take look intensity function . functions bahavior.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"intensity-function-lambda","dir":"Articles","previous_headings":"Setup > Intensity, cumulative intensity, and inverse cumulative intensity functions","what":"Intensity function λ()\\lambda()","title":"Sampling log-linear times","text":"Define vectorized form intensity function. Arguments alpha beta can scalars vectors (column matrices). Argument t can scalar, vector KK ages (times), K×sK \\times s matrix. See examples behavior vectorized function. ellipses (...) allow l() ignore extra arguments without breaking execution script. won’t purpose, sampling functions nhppp package take function arguments need ability pass optional extraneous arguments. Scalar arguments, evaluated t = 45 Scalar arguments, evaluated t = 45:50 (vector) column matrix function returns results format t argument. Vector arguments, using first 5 people evaluating people t = 45 Matrix arguments convenient: rows people columns ages (times) – can differ across persons. first 5 people, evaluate different age person. results returned matrix format. first 5 people, evaluate three different ages person. arrange t_mat matrix ages (times) people rows ages (times) person columns. results returned matrix format. defaults alpha beta arguments l() functions respective columns whole population. can evaluate intensity function λ()\\lambda() whole population passing t argument.","code":"l <- function(t, alpha = pop$alpha, beta = pop$beta, ...) exp(alpha + beta * t) l(t = 45, alpha = -4, beta = 0.03) #> [1] 0.07065121 l(t = 45:50, alpha = -4, beta = 0.03) #> [1] 0.07065121 0.07280286 0.07502004 0.07730474 0.07965902 0.08208500  l(t = matrix(45:50, ncol = 1), alpha = -4, beta = 0.03) #>            [,1] #> [1,] 0.07065121 #> [2,] 0.07280286 #> [3,] 0.07502004 #> [4,] 0.07730474 #> [5,] 0.07965902 #> [6,] 0.08208500 l(t = 45, alpha = pop$alpha[1:5], beta = pop$beta[1:5]) #> [1] 0.04943966 0.06380303 0.05296605 0.03496243 0.06470944 l(t = matrix(c(45, 50, 45, 47.4, 30), ncol = 1), alpha = pop$alpha[1:5], beta = pop$beta[1:5]) #>            [,1] #> [1,] 0.04943966 #> [2,] 0.07494128 #> [3,] 0.05296605 #> [4,] 0.03691928 #> [5,] 0.04142702 t_mat <- matrix(c(   45, 50, 45, 47.4, 30,   45.1, 50.1, 45.5, 47.8, 38,   48, 52.7, 60.1, 70.1, 99.9 ), ncol = 3, byrow = TRUE) t_mat #>      [,1] [,2] [,3] #> [1,] 45.0 50.0 45.0 #> [2,] 47.4 30.0 45.1 #> [3,] 50.1 45.5 47.8 #> [4,] 38.0 48.0 52.7 #> [5,] 60.1 70.1 99.9  l(t = t_mat, alpha = pop$alpha[1:5], beta = pop$beta[1:5]) #>            [,1]       [,2]       [,3] #> [1,] 0.04943966 0.05719509 0.04943966 #> [2,] 0.06892608 0.03937330 0.06400868 #> [3,] 0.06145926 0.05374399 0.05747231 #> [4,] 0.02982757 0.03742537 0.04163741 #> [5,] 0.10137780 0.13647889 0.33101750 t_mat <- matrix(rep(c(45, 50, 55), each = K), ncol = 3, byrow = TRUE) l(t = t_mat) |> head() #>            [,1]       [,2]       [,3] #> [1,] 0.04943966 0.04943966 0.04943966 #> [2,] 0.06380303 0.06380303 0.06380303 #> [3,] 0.05296605 0.05296605 0.05296605 #> [4,] 0.03496243 0.03496243 0.03496243 #> [5,] 0.06470944 0.06470944 0.06470944 #> [6,] 0.08214702 0.08214702 0.08214702"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"cumulative-intensity-function-lambdat","dir":"Articles","previous_headings":"Setup > Intensity, cumulative intensity, and inverse cumulative intensity functions","what":"Cumulative intensity function Λ(t)\\Lambda(t)","title":"Sampling log-linear times","text":"cumulative intensity function Λ(,t)=∫atλ(s)ds\\Lambda(, t) = \\int_a^t \\lambda(s) \\ \\textrm{d}s. matter choose lower limit integration definition Λ\\Lambda. lower limit cancels mathematics sampling algorithms. Thus free use lower limit (say 0) antiderivative λ()\\lambda() convenient (integration constant). slight abuse notation, define 0 lower integration limit write Λ(t):=Λ(0,t)=∫0tλ(s)ds{\\Lambda(t) := \\Lambda(0, t) = \\int_0^t \\lambda(s) \\ \\textrm{d}s}. log-linear intensity example, Λ(t)=1β(eα+βt−eα)\\Lambda(t) = \\frac{1}{\\beta} (e^{\\alpha + \\beta t} - e^\\alpha). vectorized version Λ\\Lambda example ","code":"L <- function(t, alpha = pop$alpha, beta = pop$beta, ...) {   (exp(alpha + beta * t) - exp(alpha)) / beta }"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"inverse-cumulative-intensity-function-lambda-1z","dir":"Articles","previous_headings":"Setup > Intensity, cumulative intensity, and inverse cumulative intensity functions","what":"Inverse cumulative intensity function Λ−1(z)\\Lambda^{-1}(z)","title":"Sampling log-linear times","text":"construction, Λ\\Lambda strictly positive monotone function tt, thus invertible. inverse cumulative intensity function Λ−1\\Lambda^{-1} defined function recovers tt pass Λ(t)\\Lambda(t). definition satisfies Λ−1(Λ(t))=t{\\Lambda^{-1} \\big ( \\Lambda(t) \\big ) = t}. example, Λ−1(z)=(log(βz+eα)−α)/β\\Lambda^{-1}(z) = \\big(\\log(\\beta z + e^\\alpha) - \\alpha\\big)/\\beta, easily derived formula Λ(t)\\Lambda(t). vectorized implementation Λ−1\\Lambda^{-1} example ","code":"Li <- function(z, alpha = pop$alpha, beta = pop$beta, ...) {   (log(beta * z + exp(alpha)) - alpha) / beta }"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"method-1-non-vectorized-sampling-with-nhpppdraw_sc_loglinear","dir":"Articles","previous_headings":"","what":"Method 1: non-vectorized sampling with nhppp::draw_sc_loglinear()","title":"Sampling log-linear times","text":"nhppp package function draw_sc_loglinear() draws times log-linear densities person time. slower methods, can practical even sizeable simulations run (e.g., statistical simulation analyses) develop code. ’s arguments intercept, slope name parameters log-linear intensity function λ\\lambda. t_min, t_max arguments ask bounds interval [Tk0,Tk1)[T_{k0}, T_{k1}). argument atmost1 asks first time. special case function uses bespoke inversion algorithm; ’s fast can without vectorization.","code":"tictoc::tic(\"Method 1 (nonvectorized)\") t_nonvec_special_case <- rep(NA, K) for (k in 1:K) {   t1 <- nhppp::draw_sc_loglinear(     intercept = pop$alpha[k],     slope = pop$beta[k],     t_min = pop$T0[k],     t_max = pop$T1[k],     atmost1 = TRUE   )   if (length(t1) != 0) {     t_nonvec_special_case[k] <- t1   } } tictoc::toc(log = TRUE) #> Method 1 (nonvectorized): 1.514 sec elapsed pop[, t_nonvec_special_case := t_nonvec_special_case]"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"method-2-vectorized-sampling-using-only-lambda","dir":"Articles","previous_headings":"","what":"Method 2: Vectorized sampling using only λ()\\lambda()","title":"Sampling log-linear times","text":"know intensity function λ\\lambda, nhppp employs thinning algorithm. One items needed thinning algorithm piecewise constant majorizer function λ*\\lambda_* : λ*(t)>=λ(t)\\lambda_*(t) >= \\lambda(t) tt interest. nhppp::vdraw_intensity function assumes provide majorizer function matrix (lambda_maj_matrix). create matrix, split simulation time (, age 40 age 100) MM equal-length intervals. person kk interval mm, element lambda_maj_matrix[k, m] records supremum λk\\lambda_k mm-th interval. supremum – algorithm efficient give least upper bound – practically, maximum λ(t)\\lambda(t) tt interval. monotone intensity functions, function example, maximum one interval’s bounds. left bound, λ\\lambda decreasing, right bound, λ\\lambda increasing. helper function nhppp generates majorizer matrix automatically monotone (possibly discontinuous) functions nonmonotone continuous Lipschitz functions (functions whose maximum slope bounded). Even case complex, able find supremum works. code samples vectorized fashion know λ()\\lambda(). creates majorizer matrix M=5M=5 intervals. let software know times correspond MM intervals suffices specify start stop time row majorizer matrix rate_matrix_t_min rate_matrix_t_max options. sampling intervals [Tk0,Tk1)[T_{k0}, T_{k1})simulated person subset interval majorizer matrix defined, specified t_min t_max options. (atmostB option can useful speed sampling minimize memory needs one interested first event . smaller value, faster algorithm check specified small. example, atmostB = 5 fine – returns exact solutions; checked [shown]. want mess , use option. function may already fast enough needs).","code":"tictoc::tic(\"Method 2 (vectorized, thinning)\") M <- 5 break_points <- seq.int(from = 40, to = 100, length.out = M + 1) breaks_mat <- matrix(rep(break_points, each = K), nrow = K)  lmaj_mat <- nhppp::get_step_majorizer(   fun = l,   breaks = breaks_mat,   is_monotone = TRUE )  pop[   ,   t_thinning := nhppp::vdraw_intensity(     lambda = l,     lambda_maj_matrix = lmaj_mat,     rate_matrix_t_min = 40,     rate_matrix_t_max = 100,     t_min = pop$T0,     t_max = pop$T1,     atmost1 = TRUE,     atmostB = 5   ) ] tictoc::toc(log = TRUE) # timer end #> Method 2 (vectorized, thinning): 0.111 sec elapsed"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"method-3-vectorized-sampling-using-lambda-and-lambda-1","dir":"Articles","previous_headings":"","what":"Method 3: Vectorized sampling using Λ()\\Lambda() and Λ−1()\\Lambda^{-1}()","title":"Sampling log-linear times","text":"efficient sampling possible one knows Λ()\\Lambda() Λ−1()\\Lambda^{-1}(). nhppp package can sample case using vdraw_cumulative_intensity() function. range_t matrix information person’s [Tk0,Tk1)[T_{k0}, T_{k1}).","code":"tictoc::tic(\"Method 3 (inversion)\") pop[   ,   t_inversion := nhppp::vdraw_cumulative_intensity(     Lambda = L,     Lambda_inv = Li,     t_min = pop$T0,     t_max = pop$T1,     atmost1 = TRUE   ) ] tictoc::toc(log = TRUE) # timer end #> Method 3 (inversion): 0.016 sec elapsed"},{"path":[]},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"simulation-time-costs","dir":"Articles","previous_headings":"Comparisons","what":"Simulation time-costs","title":"Sampling log-linear times","text":"simulation time-costs see document depend machine rendered . read online, machine probably virtual server minimal resources. installed package locally, probably machine using run R. Method 1 (nonvectorized): 1.514 sec elapsed. slowest approach – still bad 10510^{5} samples! Method 2 (vectorized, thinning): 0.111 sec elapsed. approach many times faster first approach. flexible – can accommodate complex time varying intensity functions. almost always know λ\\lambda can get majorizer λ*\\lambda_* easily fast. Method 3 (inversion): 0.016 sec elapsed. approach many times faster second one, requires implementations Λ\\Lambda Λ−1\\Lambda^{-1}.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"simulated-times","dir":"Articles","previous_headings":"Comparisons","what":"Simulated times","title":"Sampling log-linear times","text":"three methods sample correctly specified log-linear process. approximation play. QQ plots compare simulated times three methods. agreement excellent population size K=105K = 10^{5}. KK increases agreement remains excellent (shown - try ). paper bibliography includes -depth comparisons. set QQ plots suffice .","code":"qqplot(pop$t_nonvec_special_case, pop$t_thinning) qqplot(pop$t_nonvec_special_case, pop$t_inversion)"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Sampling log-linear times","text":"Thanks Carolyn Rutter Hui Hsuan Chan providing numerical example vignette.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"bibliography","dir":"Articles","previous_headings":"","what":"Bibliography","title":"Sampling log-linear times","text":"Trikalinos TA, Sereda Y. nhppp: Simulating Nonhomogeneous Poisson Point Processes R. arXiv preprint arXiv:2402.00358. 2024 Feb 1. Since publication paper, syntax options nhppp package evolved. reproduce code paper, install version nhppp used paper. Alternatively, take look vignettes, written work current package.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"the-simulation-world","dir":"Articles","previous_headings":"","what":"The simulation world","title":"A simple discrete event simulation model of a cancer's natural history","text":"model cancer’s natural history population. index people k∈[K]:={1,…,K}k \\[K] := \\{1, \\dots, K \\}. following assumptions fix simulation world. types events can modeleld nonhomogeneous Poisson point processes (NHPPPs). Persons alive cancer free 40 years age. person live past 110 years. people can die causes cancer interest (hereafter, death causes). Write ρk(t)\\rho_k(t) corresponding intensity function. people may exposed environmental toxin, exposure varies time. Write ξk(t)≥0\\xi_k(t) \\ge 0 exposure function. Positive values mean person exposed particular instance. (never exposed zeros throughout life.) assume exposure said toxin risk factor cancer emergence, toxin cumulative effects – instantaneous exposure levels matter. Write δk\\delta_k effect toxin instantaneous exposure developing cancer. persons develop preclinical cancer time-varying intensity function λk(t)=λk0(t)⏟non-risk factor part+δkξk(t)⏟risk factor part\\lambda_{k}(t) = \\underbrace{\\lambda_{k0}(t)}_{\\textrm{non-risk factor part}} + \\underbrace{\\delta_k \\ \\xi_k(t)}_{\\textrm{risk factor part}}. preclinical cancers may progress clinical cancer intensity function μk(t)\\mu_k(t), point considered diagnosed. people develop preclinical cancer can die cancer intensity function νk(t)\\nu_k(t). cancer death rate explicitly depend whether cancer diagnosed . Thus, two competing causes death: death due cancer due causes.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"A simple discrete event simulation model of a cancer's natural history","text":"Load nhppp data.table. (prefer use data.table, able implement example base R little trouble.)","code":"library(data.table) library(nhppp)"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"simulation-model","dir":"Articles","previous_headings":"","what":"Simulation model","title":"A simple discrete event simulation model of a cancer's natural history","text":"now fix mathematical description model. simulate K=104K = 10^{4} males females (equal probability) 2015 birth cohort.","code":"pop <- data.table(   id = 1:K,   birth_cohort = 2015,   spawn_age = 40,   max_simulation_age = 110,   sex = sample(c(\"male\", \"female\"), K, replace = TRUE) )  ## It would make sense to execute the commented-out code now. ## It generates model parameters used in later stages. ## For expository clarity, we generate each parameter when it is introduced # pop[, `:=`( #    param_cancer_emergence_shape = runif(.N, 7, 9), #    param_cancer_emergence_scale = rnorm(.N, 150, 20), #    param_toxin_exposure_diff = pmax(0.005, rnorm(.N, 0.01, 0.005)), #    param_cancer_death_intercept := rnorm(.N, -2, 0.5), #    param_cancer_death_slope := runif(n= .N, min = 0, max = 0.003), #    param_clinical_cancer_dx_rate := runif(.N, 0.20, 0.27) #  )]"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"death-from-other-causes","dir":"Articles","previous_headings":"Simulation model","what":"Death from other causes","title":"A simple discrete event simulation model of a cancer's natural history","text":"death causes ρk(t)\\rho_k(t) depends age (tt, measured years), sex (male female), birth year person kk. Function ρ\\rho piecewise constant year age. `regular’ step function (steps length one year). cancer major cause death, intensity function cause deaths good approximation intensity function death causes. internal dataset annual_mortality_rates_2015 cause mortality data 2015 birth cohort. values piecewise constant ρ\\rho per birth cohort, sex, age. peek columns. step (piecewise constant) intensity function regular time intervals (, one year long), can use nhppp’s vdraw_sc_step_regular() function. need specify following: Pass intensities matrix (argument lambda_matrix); number columns matrix number time intervals step function. Give information long time step , specifying age bounds rate_matrix_t_min rate_matrix_t_max intensity matrix applies; Optionally, want sample times sub-interval (rate_matrix_t_min, rate_matrix_t_max], can specify even narrower bounds, t_min t_max. omit t_min t_max, software uses rate_matrix_t_min rate_matrix_t_max, respectively, specify sampling interval. person lives beyond maximum simulation age 110 years, need force simulation least one death event simulation interval. means sampling zero-truncated NHPPP. Setting option atleast1 TRUE achieves . need sample earliest event NHPPP. set atmost1 option TRUE.","code":"annual_mortality_rates_2015[   sex %in% c(\"male\", \"female\"),   c(1:5, 111:113) ] #> Key: <birth_cohort, sex> #>    birth_cohort    sex    age_0    age_1    age_2  age_108  age_109 age_110+ #>           <int> <fctr>    <num>    <num>    <num>    <num>    <num>    <num> #> 1:         2015 female 0.005386 0.000350 0.000228 0.559371 0.541174 0.587413 #> 2:         2015   male 0.006404 0.000452 0.000277 0.511677 0.671391 0.386100 rhos <- annual_mortality_rates_2015[   pop,   on = c(\"birth_cohort\", \"sex\") ] setindex(rhos, \"id\") rho_matrix <- as.matrix(rhos[, c(paste0(\"age_\", 0:109), \"age_110+\"),   with = FALSE ])  rm(list = \"rhos\") # cleanup pop[   ,   age_dead_from_other_causes :=     nhppp::vdraw_sc_step_regular(       lambda_matrix = rho_matrix,       rate_matrix_t_min = 0,       rate_matrix_t_max = 110,       t_min = pop$spawn_age, # 40       t_max = pop$max_simulation_age, # 110       atmost1 = TRUE,       atleast1 = TRUE     ) ]"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"environmental-toxin-exposure-histories","dir":"Articles","previous_headings":"Simulation model","what":"Environmental toxin exposure histories","title":"A simple discrete event simulation model of a cancer's natural history","text":"generate environmental exposure histories phenomenological model. assume People may exposed environmental toxin probability pstart=0.20p_{start} = 0.20. exposed, start age exposure tk0∼U(12,35)t_{k0} \\sim U(12, 35), provided still alive. Among exposed, probability exposure eventually stop pstop=0.60p_{stop} = 0.60. pertinent subgroup persons, duration exposure dk∼U(1,35)d_k \\sim U(1, 35), still alive. people least exposure toxin, times exposure window (tk0,tk1](t_{k0}, t_{k1}] exposure levels ξk(t)=Ξk⋅(12+14(cos(0.5t)+cos(0.45t)))\\xi_k(t) = \\Xi_k \\cdot \\Big(\\frac{1}{2} +\\frac{1}{4}\\big(\\cos(0.5 t) + \\cos(0.45 t) \\big) \\Big), tt person’s age amplitude (maximum exposure) Ξk\\Xi_k model Ξk∼U(0.2,1)\\Xi_k \\sim U(0.2, 1). Otherwise, ξk(t)=0\\xi_k(t) = 0. now add per-person parameters exposure histories population data.table. people never exposed set Ξk\\Xi_k zero, exposure start stop ages max_simuation_age. avoids ... else statements, still pretty fast. run massive model, though, may want smarter . implement ξk(t)\\xi_k(t) function vectorized arguments. arguments start_age, stop_age, max_exposure correspond variables tk0,tk1,Ξt_{k0}, t_{k1}, \\Xi equation .","code":"pop[, `:=`(   exposure_start_age = max_simulation_age,   exposure_stop_age = max_simulation_age,   maximum_exposure = 0 )][   ,   will_start_exposure := runif(.N) < 0.20 ][   will_start_exposure == TRUE,   will_stop_exposure := runif(.N) < 0.60 ][   will_start_exposure == TRUE,   exposure_start_age := pmin(runif(.N, 12, 35), age_dead_from_other_causes) ][   will_stop_exposure == TRUE,   exposure_stop_age := pmin(     exposure_start_age + runif(.N, 1, 35),     age_dead_from_other_causes   ) ][   will_start_exposure == TRUE,   maximum_exposure := runif(.N, 1 / 5, 1) ]  # cleanup pop[, will_start_exposure := NULL][, will_stop_exposure := NULL] xi <- toxin_exposure <- function(t, max_exposure, start_age, stop_age) {   (start_age <= t) * (stop_age >= 1) * max_exposure * (1 / 2 + (cos(t / 2) + cos(0.9 * t / 2)) / 4) }"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"emergence-of-pre-clinical-cancer-in-unexposed-and-exposed-intervals","dir":"Articles","previous_headings":"Simulation model","what":"Emergence of pre-clinical cancer in unexposed and exposed intervals","title":"A simple discrete event simulation model of a cancer's natural history","text":"Assume intensity function cancer emergence absence toxin exposure λk0(t)=shapekscalek(tscalek)shapek−1\\lambda_{k0}(t) = \\frac{shape_k}{scale_k} \\Big(\\frac{t}{scale_k}\\Big)^{shape_k -1}, tt age years. intensity function generates Weibull point process (special case NHPPP). parameters shapekshape_k scalekscale_k assumed vary across people according models shapek∼U(7,9)shape_k \\sim U(7, 9) scalek∼N(150,20)scale_k \\sim N(150, 20), U(⋅)U(\\cdot) N(⋅)N(\\cdot) stand uniform normal distributions. sample values person population. Generating Weibull point process easy R using stats::rweibull() function. (take care cancer emergence times people without toxin exposure, people toxin exposures.) Accounting toxin exposure histories, intensity function cancer emergence λk(t)=lk0(t)+δkξk(t)\\lambda_{k}(t) = l_{k0}(t) + \\delta_k \\xi_k(t). assume toxin exposure effect δk\\delta_k distributed δk∼N+(2,0.5)\\delta_k \\sim N_+\\big(2, 0.5\\big), N+(⋅)N_+(\\cdot) slab smear normal distribution. need sample NHPPP intensity function varies time per λk(t)\\lambda_k(t). use nhppp’s vdraw_intensity() function, needs intensity function (argument lambda) vectorized form, age tt needed argument arguments set default. majorizer piecewise constant function, specified matrix lambda_maj_matrix. rate_matrix_t_min, rate_matrix_t_max arguments specify time bounds matrix lambda_maj_matrix. t_min, t_max arguments, subinterval whchi sample times. , t_min = 40 – spawn age simulation, t_max age_dead_from_other_causes. Let’s implement . intensity function specified follows. Observe vectorized form. also need piecewise constant majorizer function λ*(t)\\lambda_*(t). say λ*(t)\\lambda_*(t) majorizes λ(t)\\lambda(t) λ*(t)≥λ(t)\\lambda_*(t) \\ge \\lambda(t) tt interest. function expects regular step majorizer function. create function M=10M = 10 equally-spaced intervals whole simulation window. First, generate endpoints MM intervals. matrix rows correspond persons columns M+1=11M + 1 =11 interval bounds. … now generate majorizer matrix using nhppp’s get_step_majorizer() function. (paper Bibliography explains function works.) now, can sample cancer generation times, create variable identify patients cancer.","code":"pop[, `:=`(   param_cancer_emergence_shape = runif(.N, 7, 9),   param_cancer_emergence_scale = rnorm(.N, 150, 20) )] pop[, param_toxin_exposure_diff := pmax(0, rnorm(.N, 0.01, 0.005))] lambda <- function(t, P = pop, ...) {   # non-risk factor part: shape / scale * (t/scale)^(shape - 1)   (P$param_cancer_emergence_shape / P$param_cancer_emergence_scale) *     (t / P$param_cancer_emergence_scale)^(P$param_cancer_emergence_shape - 1) +     # risk factor (toxin exposure) part: delta_k * xi(t)     P$param_toxin_exposure_diff *       xi(         t = t,         max_exposure = P$maximum_exposure,         start_age = P$exposure_start_age,         stop_age = P$exposure_stop_age       ) } # define interval bounds for the step function, one row per person M <- 10 time_breaks <- matrix(   data = rep(x = seq(from = 40, to = 110, length.out = M + 1), each = K),   byrow = FALSE,   nrow = K )  time_breaks[1:3, ] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #> [1,]   40   47   54   61   68   75   82   89   96   103   110 #> [2,]   40   47   54   61   68   75   82   89   96   103   110 #> [3,]   40   47   54   61   68   75   82   89   96   103   110 lambda_star <- nhppp::get_step_majorizer(   fun = lambda,   breaks = time_breaks,   is_monotone = FALSE,   K = 1.9 / 4 # This is the maximum slope of xi() -- which you get with some calculus )  lambda_star[1:3, ] #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     [,8] #> [1,] 1.662507 1.662520 1.662549 1.662608 1.662719 1.662918 1.663257 1.663810 #> [2,] 1.662539 1.662591 1.662691 1.662869 1.663168 1.663648 1.664388 1.665489 #> [3,] 1.662542 1.662609 1.662752 1.663035 1.663554 1.664454 1.665944 1.668315 #>          [,9]    [,10] #> [1,] 1.664681 1.666012 #> [2,] 1.667083 1.669331 #> [3,] 1.671963 1.677415 pop[   ,   age_cancer_emergence := nhppp::vdraw_intensity(     lambda = lambda,     lambda_maj_matrix = lambda_star,     rate_matrix_t_min = 40,     rate_matrix_t_max = 110,     t_min = pop$spawn_age,     t_max = pmin(pop$age_dead_from_other_causes, 110, na.rm = TRUE),     atmost1 = TRUE   ) ][   ,   with_cancer := !is.na(age_cancer_emergence), ]"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"dying-from-cancer","dir":"Articles","previous_headings":"Simulation model","what":"Dying from cancer","title":"A simple discrete event simulation model of a cancer's natural history","text":"People preclinical cancer may die cancer causes. assume intensity cancer deaths loglinear time, νk=eαk+βkt\\nu_k = e^{\\alpha_k + \\beta_k t}, parameters αk∼N(−3,0.2)\\alpha_k \\sim N(-3, 0.2) βkU(0,0.003)\\beta_k ~ U(0, 0.003). use vdraw_intensity() function , since already know intensity νk\\nu_k can easily create majorizer function , generated cancer emergence times. plenty fast small simulation K=104K = 10^{4} requires additional mathematics. can sample even faster can analytically obtain cumulative intensity function Nk(t)=∫0tνk(s)dsN_k(t) = \\int_0^t{\\nu_k(s) \\ \\textrm{d}s}, inverse Nk−1(z)N_k^{-1}(z). (inverse function recovers tt value Nk(t)N_k(t): t=Nk−1(Nk(t))t = N_k^{-1}\\big( N_k(t)\\big)). sampling done nhppp’s vdraw_cumulative_intensity() function. bit calculus can yield Nk(t)=1βk(eαk+βkt−eαk)N_k(t) = \\frac{1}{\\beta_k} (e^{\\alpha_k + \\beta_k t} - e^{\\alpha_k}), can implement vectorized form default parameters already set: inverse Nk−1(⋅)N_k^{-1}(\\cdot) $N_k^{-1}(z) = ( ( _k z + e^_k ) - _k )/_k $ , can sample times cancer death.","code":"pop[, param_cancer_death_intercept := rnorm(.N, -3, 0.2)] pop[, param_cancer_death_slope := runif(.N, 0, 0.003)] Nu <- function(t, Lambda_args = list(population), ...) {   P <- Lambda_args$population   (     exp(P$param_cancer_death_intercept + P$param_cancer_death_slope * t) -       exp(P$param_cancer_death_intercept)   ) / P$param_cancer_death_slope } Nu_inv <- function(z, Lambda_inv_args = list(population), ...) {   P <- Lambda_inv_args$population   (     log(P$param_cancer_death_slope * z +       exp(P$param_cancer_death_intercept)) -       P$param_cancer_death_intercept   ) / P$param_cancer_death_slope } args_list <- list(population = pop[!is.na(age_cancer_emergence), ]) pop[   !is.na(age_cancer_emergence),   age_dead_from_cancer_causes := nhppp::vdraw_cumulative_intensity(     Lambda = Nu,     Lambda_args = args_list,     Lambda_inv = Nu_inv,     Lambda_inv_args = args_list,     t_min = pop[!is.na(age_cancer_emergence), age_cancer_emergence],     t_max = pop[!is.na(age_cancer_emergence), age_dead_from_other_causes],     atmost1 = TRUE   ) ]  rm(list = \"args_list\") # cleanup"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"dying-from-all-causes","dir":"Articles","previous_headings":"Simulation model","what":"Dying from all causes","title":"A simple discrete event simulation model of a cancer's natural history","text":"age death causes minimum ages across causes death.","code":"pop[   ,   age_dead := pmin(age_dead_from_other_causes,     age_dead_from_cancer_causes,     na.rm = TRUE   ) ]"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"clinical-cancer-diagnosis","dir":"Articles","previous_headings":"Simulation model","what":"Clinical cancer diagnosis","title":"A simple discrete event simulation model of a cancer's natural history","text":"Cancers first emerge pre-clinical stage. diagnosed clinical cancers intensity function μk\\mu_k. assume clinical diagnosis constant rate distributed according model μk(t):=μk∼U(0.20,0.27)\\mu_k(t) := \\mu_k \\sim U(0.20, 0.27), kk indexes people cancer. Constant rates result exponential times, can easily sample stats::rexp() function, per commented code . nhppp, can use vdraw_sc_step_regular() function samples piecewise constant intensities. (constant function interval still piecewise constant function – single piece.) nhppp implementation bit slower – worth showing.","code":"pop[   !is.na(age_cancer_emergence),   param_clinical_cancer_dx_rate := runif(.N, 0.20, 0.27) ] ### Using rexp() tictoc::tic() pop[   !is.na(age_cancer_emergence),   age_clinical_cancer_dx :=     age_cancer_emergence +     rexp(.N, rate = param_clinical_cancer_dx_rate) ] pop[   age_clinical_cancer_dx >= age_dead,   age_clinical_cancer_dx := NA ] tictoc::toc() #> 0.003 sec elapsed tictoc::tic() mu_mat <- as.matrix(pop[   !is.na(age_cancer_emergence),   param_clinical_cancer_dx_rate ])  pop[   !is.na(age_cancer_emergence),   age_clinical_cancer_dx := nhppp::vdraw_sc_step_regular(     lambda_matrix = mu_mat,     rate_matrix_t_min = pop[!is.na(age_cancer_emergence), age_cancer_emergence],     rate_matrix_t_max = pop[!is.na(age_cancer_emergence), age_dead],     atmost1 = TRUE   ) ] tictoc::toc() #> 0.003 sec elapsed"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"some-descriptives","dir":"Articles","previous_headings":"","what":"Some descriptives","title":"A simple discrete event simulation model of a cancer's natural history","text":"","code":"# pop$age_cancer_emergence |> summary() summary(pop) #>        id         birth_cohort    spawn_age  max_simulation_age #>  Min.   :    1   Min.   :2015   Min.   :40   Min.   :110        #>  1st Qu.: 2501   1st Qu.:2015   1st Qu.:40   1st Qu.:110        #>  Median : 5000   Median :2015   Median :40   Median :110        #>  Mean   : 5000   Mean   :2015   Mean   :40   Mean   :110        #>  3rd Qu.: 7500   3rd Qu.:2015   3rd Qu.:40   3rd Qu.:110        #>  Max.   :10000   Max.   :2015   Max.   :40   Max.   :110        #>                                                                 #>      sex            age_dead_from_other_causes exposure_start_age #>  Length:10000       Min.   : 40.00             Min.   : 12.01     #>  Class :character   1st Qu.: 72.82             1st Qu.:110.00     #>  Mode  :character   Median : 82.54             Median :110.00     #>                     Mean   : 80.17             Mean   : 92.71     #>                     3rd Qu.: 89.55             3rd Qu.:110.00     #>                     Max.   :110.00             Max.   :110.00     #>                                                                   #>  exposure_stop_age maximum_exposure param_cancer_emergence_shape #>  Min.   : 13.78    Min.   :0.0000   Min.   :7.000                #>  1st Qu.:110.00    1st Qu.:0.0000   1st Qu.:7.491                #>  Median :110.00    Median :0.0000   Median :7.987                #>  Mean   :101.92    Mean   :0.1221   Mean   :7.989                #>  3rd Qu.:110.00    3rd Qu.:0.0000   3rd Qu.:8.481                #>  Max.   :110.00    Max.   :0.9998   Max.   :9.000                #>                                                                  #>  param_cancer_emergence_scale param_toxin_exposure_diff age_cancer_emergence #>  Min.   : 81.73               Min.   :0.000000          Min.   : 40.19       #>  1st Qu.:136.20               1st Qu.:0.006734          1st Qu.: 59.45       #>  Median :149.56               Median :0.010018          Median : 71.85       #>  Mean   :149.79               Mean   :0.010122          Mean   : 70.34       #>  3rd Qu.:163.17               3rd Qu.:0.013482          3rd Qu.: 81.85       #>  Max.   :231.62               Max.   :0.028532          Max.   :101.70       #>                                                         NA's   :9548         #>  with_cancer     param_cancer_death_intercept param_cancer_death_slope #>  Mode :logical   Min.   :-3.733               Min.   :4.129e-07        #>  FALSE:9548      1st Qu.:-3.134               1st Qu.:7.549e-04        #>  TRUE :452       Median :-3.002               Median :1.518e-03        #>                  Mean   :-3.000               Mean   :1.501e-03        #>                  3rd Qu.:-2.866               3rd Qu.:2.239e-03        #>                  Max.   :-2.226               Max.   :2.999e-03        #>                                                                        #>  age_dead_from_cancer_causes    age_dead      param_clinical_cancer_dx_rate #>  Min.   : 42.96              Min.   : 40.00   Min.   :0.200                 #>  1st Qu.: 62.55              1st Qu.: 72.25   1st Qu.:0.217                 #>  Median : 75.08              Median : 82.17   Median :0.235                 #>  Mean   : 73.72              Mean   : 79.81   Mean   :0.235                 #>  3rd Qu.: 85.19              3rd Qu.: 89.32   3rd Qu.:0.254                 #>  Max.   :105.72              Max.   :110.00   Max.   :0.270                 #>  NA's   :9749                                 NA's   :9548                  #>  age_clinical_cancer_dx #>  Min.   : 40.45         #>  1st Qu.: 60.03         #>  Median : 73.32         #>  Mean   : 71.21         #>  3rd Qu.: 81.37         #>  Max.   :100.73         #>  NA's   :9689"},{"path":"https://bladder-ca.github.io/nhppp/articles/Simple_des_model_cancer_natural_Hx.html","id":"bibliography","dir":"Articles","previous_headings":"","what":"Bibliography","title":"A simple discrete event simulation model of a cancer's natural history","text":"Trikalinos TA, Sereda Y. nhppp: Simulating Nonhomogeneous Poisson Point Processes R. arXiv preprint arXiv:2402.00358. 2024 Feb 1. Since publication paper, syntax options nhppp package evolved. reproduce code paper, install version nhppp used paper. Alternatively, take look vignettes, written work current package.","code":""},{"path":"https://bladder-ca.github.io/nhppp/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thomas Trikalinos. Author, maintainer, copyright holder. Yuliia Sereda. Author.","code":""},{"path":"https://bladder-ca.github.io/nhppp/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Trikalinos TA, Sereda Y (2024). nhppp: Simulating Nonhomogeneous Poisson Point Processes R.","code":"@Manual{,   title = {nhppp: Simulating Nonhomogeneous Poisson Point Processes in R},   author = {Thomas A. Trikalinos and Yuliia Sereda},   year = {2024}, }"},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"nhppp-","dir":"","previous_headings":"","what":"Simulating Nonhomogeneous Poisson Point Processes","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"nhppp package simulating events one dimensional nonhomogeneous Poisson point processes (NHPPPs). functions based three algorithms provably sample target NHPPP: time-transformation homogeneous Poisson process (intensity one) via inverse integrated intensity function; generation Poisson number order statistics fixed density function; thinning majorizing NHPPP via acceptance-rejection scheme. developed provide fast memory efficient functions discrete event statistical simulations. description algorithms numerical comparison R packages, see Trikalinos Sereda (2024), accessible https://arxiv.org/abs/2402.00358.","code":""},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"can install release version nhppp CRAN : can install development version nhppp GitHub :","code":"install.packages(\"nhppp\") # install.packages(\"devtools\") devtools::install_github(\"bladder-ca/nhppp\")"},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"examples use generic function draw(), wrapper packages specific functions. draw() non-vectorized function, nhppp includes vectorized functions fast small memory footprint. Consider time varying intensity function λ(t)=e(0.2t)(1+sint)\\lambda(t) = e^{(0.2t)} (1 + \\sin t), sinusoidal intensity function exponential amplitude. draw samples interval (0,6π](0, 6\\pi] execute line_majorizer_intercept line_majorizer_slope define majorizer constant. available, integrated intensity function Λ(t)=∫0tλ(s)ds\\Lambda(t) = \\int_0^t \\lambda(s) \\ ds inverse Λ−1(z)\\Lambda^{-1}(z) result faster simulation times. example, Λ(t)=e0.2t(0.2sint−cost)+11.04+e0.2t−10.2\\Lambda(t) = \\frac{e^{0.2t}(0.2 \\sin t - \\cos t)+1}{1.04} + \\frac{e^{0.2t} - 1}{0.2}; Λ−1(z)\\Lambda^{-1}(z) constructed numerically upfront (can calculated numerically function, computational cost).","code":"l <- function(t) (1 + sin(t)) * exp(0.2 * t) nhppp::draw(   lambda = l,   line_majorizer_intercept = l(6 * pi),   line_majorizer_slope = 0,   t_min = 0,   t_max = 6 * pi ) |>   head(n = 20) #>  [1] 1.197587 1.238620 1.497499 1.713629 1.761914 2.256739 2.537528 3.622938 #>  [9] 5.822574 6.064265 6.645696 6.651551 6.684603 6.875765 6.891348 7.130680 #> [17] 7.446557 7.453139 7.545474 7.557381 L <- function(t) {   exp(0.2 * t) * (0.2 * sin(t) - cos(t)) / 1.04 +     exp(0.2 * t) / 0.2 - 4.038462 } Li <- stats::approxfun(x = L(seq(0, 6 * pi, 10^-3)), y = seq(0, 6 * pi, 10^-3), rule = 2)  nhppp::draw(Lambda = L, Lambda_inv = Li, t_min = 0, t_max = 6 * pi) |>   head(n = 20) #>  [1] 0.01152846 0.23558627 0.32924742 0.49921843 0.63509297 1.36677413 #>  [7] 2.38941548 3.19511655 3.28049866 4.62140995 5.96916564 6.37504015 #> [13] 6.68283108 6.76577784 7.12919141 7.29249262 7.38665270 7.92953383 #> [19] 7.94791744 7.96591106"},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"vectorized-functions","dir":"","previous_headings":"","what":"Vectorized functions","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"See vignette “Log-linear times”.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_exp_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Definite integral of l = exp(intercept + slope*t) at time t with L(t0) = 0 — Lambda_exp_form","title":"Definite integral of l = exp(intercept + slope*t) at time t with L(t0) = 0 — Lambda_exp_form","text":"Definite integral l = exp(intercept + slope*t) starting t0 – l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_exp_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Definite integral of l = exp(intercept + slope*t) at time t with L(t0) = 0 — Lambda_exp_form","text":"","code":"Lambda_exp_form(t, intercept, slope, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_exp_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Definite integral of l = exp(intercept + slope*t) at time t with L(t0) = 0 — Lambda_exp_form","text":"t (double) time point intercept (double) intercept slope (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_exp_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse of the definite integral of l = exp(intercept + slope*t) at time t — Lambda_inv_exp_form","title":"Inverse of the definite integral of l = exp(intercept + slope*t) at time t — Lambda_inv_exp_form","text":"Inverse definite integral l = exp(intercept + slope*t) l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_exp_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse of the definite integral of l = exp(intercept + slope*t) at time t — Lambda_inv_exp_form","text":"","code":"Lambda_inv_exp_form(z, intercept, slope, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_exp_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse of the definite integral of l = exp(intercept + slope*t) at time t — Lambda_inv_exp_form","text":"z (double) value integrated rate want find time intercept (double) intercept slope (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_linear_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse of the definite integral of l = intercept + slope*t at time t — Lambda_inv_linear_form","title":"Inverse of the definite integral of l = intercept + slope*t at time t — Lambda_inv_linear_form","text":"Inverse definite integral l = intercept + slope*t l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_linear_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse of the definite integral of l = intercept + slope*t at time t — Lambda_inv_linear_form","text":"","code":"Lambda_inv_linear_form(z, intercept, slope, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_linear_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse of the definite integral of l = intercept + slope*t at time t — Lambda_inv_linear_form","text":"z (double) value integrated rate want find time intercept (double) intercept slope (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_linear_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Definite integral of l = intercept + slope*t at time t with L(t0) = 0 — Lambda_linear_form","title":"Definite integral of l = intercept + slope*t at time t with L(t0) = 0 — Lambda_linear_form","text":"Definite integral l = intercept + slope*t starting t0 – l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_linear_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Definite integral of l = intercept + slope*t at time t with L(t0) = 0 — Lambda_linear_form","text":"","code":"Lambda_linear_form(t, intercept, slope, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_linear_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Definite integral of l = intercept + slope*t at time t with L(t0) = 0 — Lambda_linear_form","text":"t (double) time point intercept (double) intercept slope (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/annual_mortality_rates_2015.html","id":null,"dir":"Reference","previous_headings":"","what":"Human mortality database age and sex specific rates for all cause deaths — annual_mortality_rates_2015","title":"Human mortality database age and sex specific rates for all cause deaths — annual_mortality_rates_2015","text":"2015 annual death rates 2023 version Human Mortality Database USA.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/annual_mortality_rates_2015.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Human mortality database age and sex specific rates for all cause deaths — annual_mortality_rates_2015","text":"","code":"annual_mortality_rates_2015"},{"path":[]},{"path":"https://bladder-ca.github.io/nhppp/reference/annual_mortality_rates_2015.html","id":"annual-mortality-rates-","dir":"Reference","previous_headings":"","what":"annual_mortality_rates_2015","title":"Human mortality database age and sex specific rates for all cause deaths — annual_mortality_rates_2015","text":"data.table 3 rows 113 columns. birth_cohort Birth cohort calendar year sex sex: female, male, total. age_0, ..., age 110+ age-specific death rates","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/annual_mortality_rates_2015.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Human mortality database age and sex specific rates for all cause deaths — annual_mortality_rates_2015","text":"https://www.mortality.org","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"Standard checks matrix ordered times (event series rows, times columns). Check times columns sorted, unique values [t_min, t_max], length size (applicable).","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"","code":"check_ppp_sample_validity(   times,   t_min,   t_max = NULL,   size = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"times (vector, double | matrix) times checked vectors matrices (time-vectors rows) t_min (double | vector) start time nterval t_max (double| vector) optional: end time interval; vector, length match number rows times. size (double) optional: size vector atmost1 (boolean) optional: one sample returned atleast1 (boolean) optional: least one sample returned","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"None","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the validity of a ppp vector. — check_ppp_vector_validity","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"Standard checks vector ordered times. Check times vector sorted, unique values, values [t_min, t_max], length size (applicable).","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"","code":"check_ppp_vector_validity(   times,   t_min,   t_max = NULL,   size = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"times (vector, double) times checked t_min (double) start time nterval t_max (double) optional: end time interval size (double) optional: size vector atmost1 (boolean) optional: one sample returned atleast1 (boolean) optional: least one sample returned","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"None","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"Compare deciles two vectors absolute difference average ratios less threshold","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"","code":"compare_ppp_vectors(ppp1, ppp2, threshold = 0.15, showQQ = TRUE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"ppp1 (vector, double) first vector ppp2 (vector, double) second vector threshold (double) optional: cutoff large absolute threshold showQQ (boolean) optional: show QQ plot absolute value Difference vs Average ratio decile bigger threshold","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"None","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"wrapper package's specific functions, thus somewhat slower. time-intensive simulations prefer one specific functions.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"","code":"draw(   Lambda = NULL,   Lambda_inv = NULL,   lambda = NULL,   line_majorizer_intercept = NULL,   line_majorizer_slope = NULL,   line_majorizer_is_loglinear = FALSE,   step_majorizer_vector = NULL,   t_min = NULL,   t_max = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"Lambda (function, double vector) integrated (cumulative) rate NHPPP Lambda_inv (function, double vector) inverse `Lambda()' lambda (function) instantaneous rate line_majorizer_intercept intercept alpha loglinear majorizer function: alpha + beta * t exp(alpha + beta * t) line_majorizer_slope slope beta loglinear majorizer function: alpha + beta * t exp(alpha + beta * t) line_majorizer_is_loglinear (boolean) TRUE majorizer loglinear exp(alpha + beta * t); FALSE linear function step_majorizer_vector (vector, double) K constant majorizing rates, one per interval; intervals equal length (regular) t_min (double) lower bound interval t_max (double) upper bound interval atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time interval","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"vector event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) over an interval when you know the cumulative intensity and its inverse. — draw_cumulative_intensity","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) over an interval when you know the cumulative intensity and its inverse. — draw_cumulative_intensity","text":"Sample NHPPP times using inversion method","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) over an interval when you know the cumulative intensity and its inverse. — draw_cumulative_intensity","text":"","code":"draw_cumulative_intensity(Lambda, Lambda_inv, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) over an interval when you know the cumulative intensity and its inverse. — draw_cumulative_intensity","text":"Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) over an interval when you know the cumulative intensity and its inverse. — draw_cumulative_intensity","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"Sample NHPPP times using inversion method, optionally using rstream generator object","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"","code":"draw_cumulative_intensity_inversion(   Lambda,   Lambda_inv,   t_min,   t_max,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"Sample NHPPP times using order statistics method, optionally using rstream generator object.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"","code":"draw_cumulative_intensity_orderstats(   Lambda,   Lambda_inv,   t_min,   t_max,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic function for simulating from NHPPPs given the intensity function. — draw_intensity","title":"Generic function for simulating from NHPPPs given the intensity function. — draw_intensity","text":"Sample NHPPPs given intensity function wrapper package's specific functions, thus somewhat slower. time-intensive simulations prefer one specific functions.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic function for simulating from NHPPPs given the intensity function. — draw_intensity","text":"","code":"draw_intensity(   lambda,   line_majorizer_intercept = NULL,   line_majorizer_slope = NULL,   line_majorizer_is_loglinear = FALSE,   step_majorizer_vector = NULL,   t_min = NULL,   t_max = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic function for simulating from NHPPPs given the intensity function. — draw_intensity","text":"lambda (function) instantaneous rate line_majorizer_intercept intercept alpha loglinear majorizer function: alpha + beta * t exp(alpha + beta * t) line_majorizer_slope slope beta loglinear majorizer function: alpha + beta * t exp(alpha + beta * t) line_majorizer_is_loglinear (boolean) TRUE majorizer loglinear exp(alpha + beta * t); FALSE linear function step_majorizer_vector (vector, double) K constant majorizing rates, one per interval; intervals equal length (regular) t_min (double) lower bound interval t_max (double) upper bound interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic function for simulating from NHPPPs given the intensity function. — draw_intensity","text":"vector event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_line.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity_line","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity_line","text":"Sample NHPPP times using thinning method","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity_line","text":"","code":"draw_intensity_line(   lambda,   majorizer_intercept,   majorizer_slope,   t_min,   t_max,   majorizer_is_loglinear = FALSE,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_line.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity_line","text":"lambda (function) instantaneous rate NHPPP. majorizer_intercept (double) intercept (alpha) loglinear majorizer function. majorizer_slope (double) slope (`beta') loglinear majorizer function. t_min (double) lower bound time interval. t_max (double) upper bound time interval. majorizer_is_loglinear (boolean) TRUE majorizer loglinear exp(alpha + beta * t) atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_line.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity_line","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"Sample NHPPP times using thinning method","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"","code":"draw_intensity_step(lambda, majorizer_vector, time_breaks, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"lambda (function) instantaneous rate NHPPP. continuous function time. majorizer_vector (scalar, double) K constant majorizing rates, one per interval time_breaks (vector, double) K+1 time points defining K intervals constant rates: [t_1 = range_t[1],       t_2): first interval [t_k,                t_{k+1}): k-th interval [t_{K}, t_{K+1} = range_t[2]): K-th (last) interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"Sample NHPPP times linear intensity function using inversion method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"","code":"draw_sc_linear(intercept, slope, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"intercept (double) intercept slope (double) slope t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"","code":"x <- draw_sc_linear(intercept = 0, slope = 0.2, t_min = 0, t_max = 10)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":null,"dir":"Reference","previous_headings":"","what":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"Sample NHPPP times log linear intensity function using inversion method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"","code":"draw_sc_loglinear(intercept, slope, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"intercept (double) intercept exponent slope (double) slope exponent t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"","code":"x <- draw_sc_loglinear(intercept = 0, slope = 0.2, t_min = 0, t_max = 10)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals need length.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"","code":"draw_sc_step(lambda_vector, time_breaks, atmost1 = FALSE, atleast1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"lambda_vector (scalar, double) K constant rates, one per interval time_breaks (vector, double) K+1 time points defining K intervals constant rates: [t_1 = range_t[1],       t_2): first interval [t_k,                t_{k+1}): k-th interval [t_{K}, t_{K+1} = range_t[2]): K-th (last) interval atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"","code":"x <- draw_sc_step(lambda_vector = rep(1, 5), time_breaks = c(0:5))"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"Sampling NHPPPs piecewise constant intensities interval lengths (non-vectorized)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"","code":"draw_sc_step_regular(   Lambda_vector = NULL,   lambda_vector = NULL,   t_min = NULL,   t_max = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"Lambda_vector (scalar, double) K integrated intensity rates end interval lambda_vector (scalar, double) K constant intensity rates, one per interval t_min (scalar, double) lower bound time interval t_max (scalar, double) upper bound time interval atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"","code":"x <- draw_sc_step_regular(Lambda_vector = 1:5, t_min = 0, t_max = 5)"},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper functions — expect_no_error","title":"Helper functions — expect_no_error","text":"helper function augments test_that::expect_no_error() expect error. Copied R6 source code.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper functions — expect_no_error","text":"","code":"expect_no_error(expr)"},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper functions — expect_no_error","text":"expr Expression.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Helper functions — expect_no_error","text":"Small utility functions. exported user.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"Return piecewise constant (step) majorizer K-Lipschitz functions interval. function vectorized breaks argument.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"","code":"get_step_majorizer(fun, breaks, is_monotone = TRUE, K = 0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"fun function object single argument x. x matrix, fun vectorized . breaks (vector matrix) set M+1 boundaries M subintervals x. breaks matrix, row treated separate set breaks. is_monotone (boolean) function monotone? (Default TRUE.) K (double) non-negative number Lipschitz cone. (Default 0.)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"vector length M values piecewise constant majorizer","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"","code":"get_step_majorizer(fun = abs, breaks = -5:5, is_monotone = FALSE, K = 1) #>  [1] 5.5 4.5 3.5 2.5 1.5 1.5 2.5 3.5 4.5 5.5"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"Numerically evaluate inverse function specific point","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"","code":"inverse_with_uniroot(   f = f,   y,   min_x = 0,   max_x = 1,   min_y = f(min_x),   max_y = f(max_x) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"f (function) function inverted; must continuous increasing y (scalar, double) f(x)=y value evaluate inverse min_x (scalar, double) min domain f() max_x (scalar, double) max domain f() min_y (scalar, double) min range f() max_y (scalar, double) max range f()","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"(scalar, double) vector x=f^(-1)(y): inverted value","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"","code":"inverse_with_uniroot(f = function(x) {   2 * x }, y = 0.5) #> [1] 0.25"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"Numerically evaluate inverse monotonically increasing continuous function R R specific points.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"","code":"inverse_with_uniroot_sorted(   f,   y,   range_x = c(0, 10),   range_y = c(f(range_x[1]), f(range_x[2])) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"f (function) function inverted; must continuous increasing y (vector, double) f(x)=y values evaluate inverse; must ascending order range_x (vector, double) min max domain f() range_y (vector, double) min max range f()","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"(vector, double) vector x=f^(-1)(y): inverted values","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"","code":"inverse_with_uniroot_sorted(f = function(x) {   2 * x }, y = c(0, 0.5)) #> [1] 0.00 0.25"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"Helper function vectorized versions sampling functions. Takes usual ways lambda_mat Lambda_mat specified returns Lambda_mat.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"","code":"make_cumulative_Lambda_matrix(   Lambda_mat = NULL,   lambda_mat = NULL,   interval_duration = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"Lambda_mat matrix cumulative intensities missing lambda_mat matrix intensities missing interval_duration vector number elements rows Lambda_mat","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"matrix (r x 2), row-expanded needed","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"Helper function vectorized versions sampling functions. Takes usual ways lambda_mat Lambda_mat specified returns lambda_mat.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"","code":"make_lambda_matrix(   lambda_mat = NULL,   Lambda_mat = NULL,   interval_duration = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"lambda_mat matrix intensities missing Lambda_mat matrix cumulative intensities missing interval_duration vector number elements rows Lambda_mat","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"matrix (r x 2), row-expanded needed","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"Helper function vectorized versions sampling functions. Takes usual ways range_t specified (2-vector, 1 x 2 r x 2 matrix) returns r x 2 matrix.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"","code":"make_range_t_matrix(range_t, n_rows)"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"range_t 2-vector, 1 x 2 r x 2 matrix n_rows number rows fully expanded matrix (r)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"matrix (r x 2), row-expanded needed","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"Return matrix column-wise cumulative sum checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"","code":"mat_cumsum_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"X (matrix)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"Return matrix column-wise cumulative sum replacing cells larger ceil NA. checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"","code":"mat_cumsum_columns_with_scalar_ceiling(X, ceil = Inf)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"X (matrix) ceil (double Inf) ceiling applied","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"Return matrix column-wise cumulative sum replacing cells larger ceil NA. checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"","code":"mat_cumsum_columns_with_vector_ceiling(X, ceil = Inf)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"X (matrix) ceil (vector Inf) set ceilings applied, per row X","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"Return matrix column-wise differencing. checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"","code":"mat_diff_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"X (matrix)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_cumsum_columns( X ) — matrix_cumsum_columns","title":"Usage: matrix_cumsum_columns( X ) — matrix_cumsum_columns","text":"Usage: matrix_cumsum_columns( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_cumsum_columns( X ) — matrix_cumsum_columns","text":"","code":"matrix_cumsum_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns_inplace.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_cumsum_columns_inplace( X ) — matrix_cumsum_columns_inplace","title":"Usage: matrix_cumsum_columns_inplace( X ) — matrix_cumsum_columns_inplace","text":"Usage: matrix_cumsum_columns_inplace( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns_inplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_cumsum_columns_inplace( X ) — matrix_cumsum_columns_inplace","text":"","code":"matrix_cumsum_columns_inplace(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_diff_columns( X ) — matrix_diff_columns","title":"Usage: matrix_diff_columns( X ) — matrix_diff_columns","text":"Usage: matrix_diff_columns( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_diff_columns( X ) — matrix_diff_columns","text":"","code":"matrix_diff_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns_inplace.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_diff_columns_inplace( X ) — matrix_diff_columns_inplace","title":"Usage: matrix_diff_columns_inplace( X ) — matrix_diff_columns_inplace","text":"Usage: matrix_diff_columns_inplace( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns_inplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_diff_columns_inplace( X ) — matrix_diff_columns_inplace","text":"","code":"matrix_diff_columns_inplace(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/nhppp-package.html","id":null,"dir":"Reference","previous_headings":"","what":"nhppp: Simulating Nonhomogeneous Poisson Point Processes — nhppp-package","title":"nhppp: Simulating Nonhomogeneous Poisson Point Processes — nhppp-package","text":"Simulates events one dimensional nonhomogeneous Poisson point processes (NHPPPs) per Trikalinos Sereda (2024, doi:10.48550/arXiv.2402.00358 ). Functions based three algorithms provably sample target NHPPP: time-transformation homogeneous Poisson process (intensity one) via inverse integrated intensity function (Cinlar E, \"Theory stochastic processes\" (1975, ISBN:0486497996)); generation Poisson number order statistics fixed density function; thinning majorizing NHPPP via acceptance-rejection scheme (Lewis PAW, Shedler, GS (1979) doi:10.1002/nav.3800260304 ).","code":""},{"path":[]},{"path":"https://bladder-ca.github.io/nhppp/reference/nhppp-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"nhppp: Simulating Nonhomogeneous Poisson Point Processes — nhppp-package","text":"Maintainer: Thomas Trikalinos thomas_trikalinos@brown.edu (ORCID) [copyright holder] Authors: Yuliia Sereda sereda_yuliia@brown.edu (ORCID)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a homogeneous Poisson Point Process in (t_min, t_max] — ppp","title":"Simulate a homogeneous Poisson Point Process in (t_min, t_max] — ppp","text":"Simulate homogeneous Poisson Point Process (t_min, t_max]","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a homogeneous Poisson Point Process in (t_min, t_max] — ppp","text":"","code":"ppp(rate, t_min, t_max, atmost1 = FALSE, tol = 10^-6)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a homogeneous Poisson Point Process in (t_min, t_max] — ppp","text":"rate (scalar, double) constant instantaneous rate t_min (scalar, double) lower bound time interval t_max (scalar, double) upper bound time interval atmost1 boolean, draw 1 event time tol probability drawn events (t_min, t_max]","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a homogeneous Poisson Point Process in (t_min, t_max] — ppp","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a homogeneous Poisson Point Process in (t_min, t_max] — ppp","text":"","code":"x <- ppp(rate = 1, t_min = 0, t_max = 10, tol = 10^-6)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp2.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp2","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp2","text":"Internal function – exported. ppp uses Order Statistics algorithm.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp2","text":"","code":"ppp2(rate, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp2","text":"rate (scalar, double) constant instantaneous rate t_min (scalar, double) lower bound time interval t_max (scalar, double) upper bound time interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp2","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp2","text":"","code":"x <- ppp(rate = 1, t_min = 0, t_max = 10, tol = 10^-6)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_exactly_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate exactly n points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_exactly_n","title":"Simulate exactly n points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_exactly_n","text":"Simulate exactly n points homogeneous Poisson Point Process (t_min, t_max]","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_exactly_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate exactly n points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_exactly_n","text":"","code":"ppp_exactly_n(n, t_min, t_max)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_exactly_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate exactly n points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_exactly_n","text":"n (int) number points simulated t_min (double) lower bound time interval t_max (double) upper bound time interval","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_exactly_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate exactly n points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_exactly_n","text":"vector event times size n","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_exactly_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate exactly n points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_exactly_n","text":"","code":"x <- ppp_exactly_n(n = 10, t_min = 0, t_max = 10)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"Use ppp_exactly_n instead.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"","code":"ppp_n(size, range_t = c(0, 10), rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"size (int) number points simulated range_t (vector, double) min max time interval rng_stream rstream object","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"vector event times size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"","code":"x <- ppp_n(size = 10, range_t = c(0, 10)) #> Warning: `ppp_n()` was deprecated in nhppp 0.5.0. #> ℹ Please use `ppp_exactly_n()` instead."},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"Simulate n events homogeneous Poisson Point Process.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"","code":"ppp_next_n(n = 1, rate = 1, t_min = 0, rng_stream = deprecated())"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"n scalar number samples rate scalar instantaneous rate t_min scalar starting time value rng_stream rstream object","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"vector event times t (starting t_min)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"","code":"x <- ppp_next_n(n = 10, rate = 1, t_min = 0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"Use ppp2 instead.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"","code":"ppp_orderstat(range_t = c(0, 10), rate = 1, rng_stream = NULL, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"range_t (vector, double) min max time interval rate (scalar, double) constant instantaneous rate rng_stream rstream object atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"","code":"x <- ppp_orderstat(range_t = c(0, 10), rate = 1) #> Warning: `ppp_orderstat()` was deprecated in nhppp 0.5.0. #> ℹ Please use `ppp2()` instead."},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"Use ppp instead.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"","code":"ppp_sequential(   range_t = c(0, 10),   rate = 1,   tol = 10^-6,   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"range_t (vector, double) min max time interval rate (scalar, double) constant instantaneous rate tol probability drawn events (t_min, t_max] rng_stream rstream object atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"","code":"x <- ppp_sequential(range_t = c(0, 10), rate = 1, tol = 10^-6) #> Warning: `ppp_sequential()` was deprecated in nhppp 0.5.0. #> ℹ Please use `ppp()` instead."},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":null,"dir":"Reference","previous_headings":"","what":"Read code from text file as string — read_code","title":"Read code from text file as string — read_code","text":"Read code text file string","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read code from text file as string — read_code","text":"","code":"read_code(codeFile)"},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read code from text file as string — read_code","text":"codeFile Path file","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read code from text file as string — read_code","text":"codeFile contents character string","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential random samples from rstream objects — rng_stream_rexp","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"","code":"rng_stream_rexp(size = 1, rate = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"size Integer, number samples rate Positive number, rate (.e., 1/mean) rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"vector exponential variates size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"","code":"rng_stream_rexp(10) #>  [1] 0.23960932 9.15313311 0.81848123 0.00278538 0.10580041 1.83457146 #>  [7] 0.26476943 0.68774057 0.45952242 3.00186797"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":null,"dir":"Reference","previous_headings":"","what":"Poisson random samples from rstream objects — rng_stream_rpois","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"","code":"rng_stream_rpois(size = 1, lambda = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"size Integer, number samples lambda Positive number, mean rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"vector counts size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"","code":"rng_stream_rpois(10) #>  [1] 0 2 2 0 1 1 1 0 0 0"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform random samples from rstream objects — rng_stream_runif","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"","code":"rng_stream_runif(size = 1, minimum = 0, maximum = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"size Integer, number samples minimum Lower bound maximum Upper bound rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"vector uniform variates size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"","code":"rng_stream_runif(10) #>  [1] 0.52610673 0.84416339 0.13599117 0.37646733 0.26330865 0.49785297 #>  [7] 0.01952525 0.08718381 0.99596266 0.94213221"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":null,"dir":"Reference","previous_headings":"","what":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"","code":"rng_stream_rztpois(size = 1, lambda = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"size Integer, number samples lambda Positive number, mean original (untruncated) Poisson distribution rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"vector non zero counts size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"","code":"rng_stream_rztpois(10) #>  [1] 1 1 1 1 2 1 1 3 2 1"},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":null,"dir":"Reference","previous_headings":"","what":"Zero-truncated Poisson random samples (basic R) — rztpois","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"Sample zero-truncated Poisson random samples (basic R)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"","code":"rztpois(n, lambda)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"n Integer, number samples lambda Positive number, mean original (untruncated) Poisson distribution","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"vector non zero counts size n","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"","code":"rztpois(10, 1) #>  [1] 1 1 2 3 2 2 1 3 2 2 rztpois(10, 1:10) #>  [1] 1 2 3 2 5 6 7 9 6 8"},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":null,"dir":"Reference","previous_headings":"","what":"Simpson's method to integrate a univariate function. — simpson_num_integr","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"Simpson's method integrate univariate continuous function. Faster R's integrate() precise enough, checks. error M (b-)^5/(180 n^4) M maximum fourth derivative integrand interval [, b].","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"","code":"simpson_num_integr(f, a, b, n)"},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"f function takes single argument lower limit integration b upper limit integration n integer, number integration points b","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"numeric, integration value examples #expect 1 simpson_num_integr(sin, 0, pi/2, 100) #max error simpson_num_integr(sin, 0, pi/2, 100) 5.312842e-10 1 * (pi/2 - 0)^5/(180 * 100^4)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"wrapper package's specific functions, thus slightly slower. time-intensive simulations prefer one specific functions.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"","code":"vdraw(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   Lambda = NULL,   Lambda_inv = NULL,   Lambda_args = NULL,   Lambda_inv_args = NULL,   t_min = NULL,   t_max = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   tol = 10^-6,   atmost1 = FALSE,   atleast1 = FALSE,   atmostB = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"lambda (function) intensity function, vectorized lambda_args (list) optional arguments pass lambda Lambda_maj_matrix (matrix) integrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval Lambda (function, double vector) increasing function integrated rate NHPPP. take vectorized argument t times optional arguments list. Lambda_inv (function, double vector) inverse Lambda(), also vectorized form take vectorized argument z optional arguments list. Lambda_args (list) optional arguments pass Lambda. Lambda_inv_args (list) optional arguments pass Lambda_inv(). t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"vector event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) given the cumulative intensity function and its inverse — vdraw_cumulative_intensity","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) given the cumulative intensity function and its inverse — vdraw_cumulative_intensity","text":"Sample NHPPP times using cumulative intensity function inverse.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) given the cumulative intensity function and its inverse — vdraw_cumulative_intensity","text":"","code":"vdraw_cumulative_intensity(   Lambda,   Lambda_inv,   t_min,   t_max,   Lambda_args = NULL,   Lambda_inv_args = NULL,   tol = 10^-6,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) given the cumulative intensity function and its inverse — vdraw_cumulative_intensity","text":"Lambda (function, double vector) increasing function integrated rate NHPPP. take vectorized argument t times optional arguments list. Lambda_inv (function, double vector) inverse Lambda(), also vectorized form take vectorized argument z optional arguments list. t_min (scalar | vector | column matrix) lower bound interval sampled point process length argument number point processes drawn. t_max (scalar | vector | column matrix) upper bound interval sampled point process length argument number point processes drawn. Lambda_args (list) optional arguments pass Lambda. Lambda_inv_args (list) optional arguments pass Lambda_inv(). tol tolerange calulations. atmost1 boolean, draw 1 event time per sampled point process. atleast1 boolean, draw least 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) given the cumulative intensity function and its inverse — vdraw_cumulative_intensity","text":"matrix event times one row per sampled point process.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity","text":"Vectorized sampling non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity","text":"","code":"vdraw_intensity(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   t_min = NULL,   t_max = NULL,   tol = 10^-6,   atmost1 = FALSE,   atleast1 = FALSE,   atmostB = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity","text":"lambda (function) intensity function, vectorized lambda_args (list) optional arguments pass lambda Lambda_maj_matrix (matrix) integrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity","text":"","code":"x <- vdraw_intensity(   lambda = function(x, ...) 0.1 * x,   lambda_maj_matrix = matrix(rep(1, 5), nrow = 1),   rate_matrix_t_min = 1,   rate_matrix_t_max = 5 )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) given the intensity function with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) given the intensity function with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"Vectorized sampling non homogeneous Poisson Point Process (NHPPP) using intensity function piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) given the intensity function with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"","code":"vdraw_intensity_step_regular_cpp(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   t_min = NULL,   t_max = NULL,   tol = 10^-6,   atmost1 = FALSE,   atmostB = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) given the intensity function with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"lambda (function) intensity function, vectorized lambda_args (list) optional arguments pass lambda Lambda_maj_matrix (matrix) integrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) given the intensity function with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_forcezt.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) – but can be forced to sample from zero-truncated proposals. — vdraw_intensity_step_regular_forcezt","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) – but can be forced to sample from zero-truncated proposals. — vdraw_intensity_step_regular_forcezt","text":"Vectorized sampling non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals. function used obtainning proposals vztdraw_intensity_step_regular()","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_forcezt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) – but can be forced to sample from zero-truncated proposals. — vdraw_intensity_step_regular_forcezt","text":"","code":"vdraw_intensity_step_regular_forcezt(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   t_min = NULL,   t_max = NULL,   tol = 10^-6,   atmost1 = FALSE,   force_zt_majorizer = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_forcezt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) – but can be forced to sample from zero-truncated proposals. — vdraw_intensity_step_regular_forcezt","text":"lambda (function) intensity function, vectorized lambda_args (list) optional arguments pass lambda Lambda_maj_matrix (matrix) integrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time force_zt_majorizer boolean, force majorizer zero-truncated. option used function called make proposals vztdraw_intensity_step_regular(). general, set option TRUE.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths — vdraw_sc_step_regular","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths — vdraw_sc_step_regular","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths — vdraw_sc_step_regular","text":"","code":"vdraw_sc_step_regular(   lambda_matrix = NULL,   Lambda_matrix = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   t_min = NULL,   t_max = NULL,   tol = 10^-6,   atmost1 = FALSE,   atmostB = NULL,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths — vdraw_sc_step_regular","text":"lambda_matrix (matrix) intensity rates, one per interval Lambda_matrix (matrix) integrated intensity rates end interval rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore. atleast1 boolean, draw least 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths — vdraw_sc_step_regular","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths — vdraw_sc_step_regular","text":"","code":"x <- vdraw_sc_step_regular(   Lambda_matrix = matrix(1:5, nrow = 1),   rate_matrix_t_min = 100,   rate_matrix_t_max = 110,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"","code":"vdraw_sc_step_regular_cpp(   lambda_matrix = NULL,   Lambda_matrix = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   t_min = NULL,   t_max = NULL,   tol = 10^-6,   atmost1 = FALSE,   atmostB = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"lambda_matrix (matrix) intensity rates, one per interval Lambda_matrix (matrix) integrated intensity rates end interval rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"matrix event times t, rows corresponding sampled point processes.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"","code":"x <- vdraw_sc_step_regular_cpp(   Lambda_matrix = matrix(1:5, nrow = 1),   rate_matrix_t_min = 100,   rate_matrix_t_max = 110,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity","text":"Vectorized sampling zero-truncated non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity","text":"","code":"vztdraw_intensity(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   range_t = NULL,   tol = 10^-6,   atmost1 = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity","text":"lambda (function) vectorized intensity function, one two arguments. first time. optional second named list additional arguments. lambda_args (list) optional list named arguments lambda() Lambda_maj_matrix (matrix) majorizeintegrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval range_t (vector, matrix) t_min t_max, possibly vectorized tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time ... () arguments (ignored  – used flexibility calling functions)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular","text":"Vectorized sampling zero-truncated non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular","text":"","code":"vztdraw_intensity_step_regular(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   t_min = NULL,   t_max = NULL,   atmost1 = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular","text":"lambda (function) intensity function, vectorized lambda_args (list) optional arguments pass lambda Lambda_maj_matrix (matrix) integrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular_cpp","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular_cpp","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular_cpp","text":"","code":"vztdraw_sc_step_regular_cpp(   lambda_matrix = NULL,   Lambda_matrix = NULL,   rate_matrix_t_min = NULL,   rate_matrix_t_max = NULL,   t_min = NULL,   t_max = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular_cpp","text":"lambda_matrix (matrix) intensity rates, one per interval Lambda_matrix (matrix) integrated intensity rates end interval rate_matrix_t_min (scalar | vector | column matrix) lower bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. rate_matrix_t_max (scalar | vector | column matrix) upper bound time interval row (Lambda|lambda)_maj_matrix. length argument number point processes drawn. t_min (scalar | vector | column matrix) lower bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_min. t_max (scalar | vector | column matrix) upper bound subinterval (rate_matrix_t_min, rate_matrix_t_max]. set, times sampled subinterval. omitted, equivalent rate_matrix_t_max. atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular_cpp","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"Sample zero-truncated NHPPP times using order statistics method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"","code":"ztdraw_cumulative_intensity(Lambda, Lambda_inv, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 (boolean) draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic function for simulating from zero-truncated NHPPPs given the intensity function. — ztdraw_intensity","title":"Generic function for simulating from zero-truncated NHPPPs given the intensity function. — ztdraw_intensity","text":"Sample zero-truncated NHPPP given intensity function wrapper package's specific functions, thus somewhat slower. time-intensive simulations prefer one specific functions.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic function for simulating from zero-truncated NHPPPs given the intensity function. — ztdraw_intensity","text":"","code":"ztdraw_intensity(   lambda,   line_majorizer_intercept = NULL,   line_majorizer_slope = NULL,   line_majorizer_is_loglinear = FALSE,   step_majorizer_vector = NULL,   t_min = NULL,   t_max = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic function for simulating from zero-truncated NHPPPs given the intensity function. — ztdraw_intensity","text":"lambda (function) instantaneous rate line_majorizer_intercept intercept alpha loglinear majorizer function: alpha + beta * t exp(alpha + beta * t) line_majorizer_slope slope beta loglinear majorizer function: alpha + beta * t exp(alpha + beta * t) line_majorizer_is_loglinear (boolean) TRUE majorizer loglinear exp(alpha + beta * t); FALSE linear function step_majorizer_vector (vector, double) K constant majorizing rates, one per interval; intervals equal length (regular) t_min (double) lower bound interval t_max (double) upper bound interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic function for simulating from zero-truncated NHPPPs given the intensity function. — ztdraw_intensity","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_line.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity_line","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity_line","text":"Sample zero-truncated NHPPP intensity times using thinning method","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity_line","text":"","code":"ztdraw_intensity_line(   lambda,   majorizer_intercept,   majorizer_slope,   t_min,   t_max,   majorizer_is_loglinear = FALSE,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_line.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity_line","text":"lambda (function) instantaneous rate NHPPP. majorizer_intercept (double) intercept (alpha) loglinear majorizer function. majorizer_slope (double) slope (`beta') loglinear majorizer function. t_min (double) lower bound time interval. t_max (double) upper bound time interval. majorizer_is_loglinear (boolean) TRUE majorizer loglinear exp(alpha + beta * t) atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_line.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity_line","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"Sample zero-truncated NHPPP times using thinning method","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"","code":"ztdraw_intensity_step(lambda, majorizer_vector, time_breaks, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"lambda (function) instantaneous rate NHPPP. continuous function time. majorizer_vector (scalar, double) K constant majorizing rates, one per interval time_breaks (vector, double) K+1 time points defining K intervals constant rates: [t_1 = range_t[1],       t_2): first interval [t_k,                t_{k+1}): k-th interval [t_{K}, t_{K+1} = range_t[2]): K-th (last) interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"vector event times (t_) least one element","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"Sample zero-truncated NHPPP times linear intensity function using inversion method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"","code":"ztdraw_sc_linear(intercept, slope, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"intercept (double) intercept slope (double) slope t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 (boolean) draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"","code":"x <- ztdraw_sc_linear(intercept = 0, slope = 0.2, t_min = 0, t_max = 10)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function — ztdraw_sc_loglinear","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function — ztdraw_sc_loglinear","text":"Sample zt-NHPPP times log-linear intensity function","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function — ztdraw_sc_loglinear","text":"","code":"ztdraw_sc_loglinear(intercept, slope, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function — ztdraw_sc_loglinear","text":"intercept (double) intercept exponent slope (double) slope exponent t_min (double) lower bound time interval t_max (double) upper bound time interval atmost1 boolean, 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function — ztdraw_sc_loglinear","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function — ztdraw_sc_loglinear","text":"","code":"x <- ztdraw_sc_loglinear(intercept = 0, slope = 0.2, t_min = 0, t_max = 10)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"Simulate zero-truncated homogeneous Poisson Point Process (t_min, t_max]","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"","code":"ztppp(rate, t_min, t_max, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"rate (scalar, double) constant instantaneous rate t_min (scalar, double) lower bound time interval t_max (scalar, double) upper bound time interval atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"vector event times size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"","code":"x <- ztppp(t_min = 0, t_max = 10, rate = 0.001)"},{"path":[]},{"path":[]},{"path":"https://bladder-ca.github.io/nhppp/news/index.html","id":"nhppp-014","dir":"Changelog","previous_headings":"","what":"nhppp 0.1.4","title":"nhppp 0.1.4","text":"CRAN release: 2024-05-28 Function arguments now consistent. extensive numerical checks. Added C++ code vectorized functions – computational speed memory efficiency.","code":""},{"path":"https://bladder-ca.github.io/nhppp/news/index.html","id":"nhppp-013","dir":"Changelog","previous_headings":"","what":"nhppp 0.1.3","title":"nhppp 0.1.3","text":"CRAN release: 2024-02-02 CRAN release","code":""},{"path":"https://bladder-ca.github.io/nhppp/news/index.html","id":"nhppp-012","dir":"Changelog","previous_headings":"","what":"nhppp 0.1.2","title":"nhppp 0.1.2","text":"Renamed functions start draw (instead nhppp_t), draw_zt (instead ztnhppp_t), vdraw (instead ending _vec()) Initial CRAN submission.","code":""}]
