[{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"simulation-description","dir":"Articles","previous_headings":"","what":"Simulation description","title":"Sampling log-linear times","text":"Assume population K=105K = 10^{5} individuals indexed k∈[K]:={1,…,K}k \\[K] := \\{ 1, \\dots, K\\}. person kk, want simulate first occurrence event (e.g., emergence tumor) age (time) interval [Tk0,Tk1)[T_{k0}, T_{k1}). example, Tk0T_{k0} may age years person kk enters simulation, Tk1T_{k1} age years person dies non-cancer causes. (practice, Tk1T_{k1} obtained separate point process.) people develop clinical cancer simulated lifetime. fix simulation scenario, let ak=40a_k = 40 kk bk∼U(50,100)b_k \\sim U(50 , 100), U()U() uniform distribution. use log-linear intensity function λk(t)=eαk+βkt\\lambda_k(t) = e^{\\alpha_k + \\beta_k t}, tt age years. parameters αk,βk\\alpha_k, \\beta_k random individuals population αk∼N(−4,0.5)\\alpha_k \\sim N(-4, 0.5), βk∼N0+(0.03,0.003)\\beta_k \\sim N_{0+}(0.03, 0.003), N()N() normal distribution N0+()N_{0+}() truncated normal distribution support [0,∞)[0, \\infty).","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"overview-of-sampling-methods-described-here","dir":"Articles","previous_headings":"","what":"Overview of sampling methods described here","title":"Sampling log-linear times","text":"use three methods: Simulate one person time looping persons. fastest way use special case function nhppp package samples log-linear intensity functions non-vectorized fashion. Yet slowest approach. Simulate persons vectorized way using intensity function λ(t)\\lambda(t). know λ(t)\\lambda(t)nhppp uses thinning algorithm. flexible approach require lot information – just λ(t)\\lambda(t). much faster first option, fast third option. Simulate persons vectorized way using cumulative intensity function Λ(t)\\Lambda(t) inverse Λ−1(z)\\Lambda^{-1}(z), defined . analytic expressions objects, get fastest sampling nhppp package. package can use inversion order statistics algorithms efficient.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Sampling log-linear times","text":"use data.tables – analysis obvious base R. use functions three packages, without loading : truncnorm package needed truncated normal distribution. tictoc() package used simple time comparison different ways one can simulate problem. stats package used generate normally uniformly distributed samples. Setup pop, population data.table. person specific parameters αk,βk,Tk0\\alpha_k, \\beta_k, T_{k0} Tk1T_{k1} variables pop.","code":"library(data.table) library(nhppp) pop <- setDT(   list(     id = 1:K,      alpha = stats::rnorm(n = K, mean = -4, sd = 0.5),     beta = truncnorm::rtruncnorm(n = K, mean = 0.03, sd = 0.003, a = 0, b = Inf),       T0 = rep(40, K),      T1 = stats::runif(n = K, min = 50, max = 100)   ) ) setindex(pop, id) pop #> Index: <id> #>             id     alpha       beta    T0       T1 #>          <int>     <num>      <num> <num>    <num> #>      1:      1 -4.318439 0.02914304    40 74.23810 #>      2:      2 -4.200092 0.03218084    40 62.26187 #>      3:      3 -4.250369 0.02916144    40 81.29045 #>      4:      4 -4.374602 0.02269157    40 94.50129 #>      5:      5 -4.075769 0.02973159    40 67.73704 #>     ---                                            #>  99996:  99996 -4.113622 0.03196925    40 71.34211 #>  99997:  99997 -5.111481 0.02665030    40 84.46180 #>  99998:  99998 -3.628798 0.02907565    40 87.67655 #>  99999:  99999 -4.438333 0.03027740    40 99.96851 #> 100000: 100000 -3.483592 0.02673899    40 57.45794"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"intensity-cumulative-intensity-and-inverse-cumulative-intensity-functions","dir":"Articles","previous_headings":"Setup","what":"Intensity, cumulative intensity, and inverse cumulative intensity functions","title":"Sampling log-linear times","text":"Define bespoke functions different simulation approaches . trick define functions work vectorized form. example, take look intensity function . functions bahavior.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"intensity-function-lambda","dir":"Articles","previous_headings":"Setup > Intensity, cumulative intensity, and inverse cumulative intensity functions","what":"Intensity function λ()\\lambda()","title":"Sampling log-linear times","text":"Define vectorized form intensity function. Arguments alpha beta can scalars vectors (column matrices). Argument t can scalar, vector KK ages (times), K×sK \\times s matrix. See examples behavior vectorized function. ellipses (...) allow l() ignore extra arguments without breaking execution script. won’t purpose, sampling functions nhppp package take function arguments need ability pass optional extraneous arguments. Scalar arguments, evaluated t = 45 Scalar arguments, evaluated t = 45:50 (vector) column matrix function returns results format t argument. Vector arguments, using first 5 people evaluating people t = 45 Matrix arguments convenient: rows people columns ages (times) – can differ across persons. first 5 people, evaluate different age person. results returned matrix format. first 5 people, evaluate three different ages person. arrange t_mat matrix ages (times) people rows ages (times) person columns. results returned matrix format. defaults alpha beta arguments l() functions respective columns whole population. can evaluate intensity function λ()\\lambda() whole population passing t argument.","code":"l <- function(t, alpha = pop$alpha, beta = pop$beta, ...) exp(alpha + beta * t) l(t = 45, alpha = -4, beta = 0.03)  #> [1] 0.07065121 l(t = 45:50, alpha = -4, beta = 0.03)  #> [1] 0.07065121 0.07280286 0.07502004 0.07730474 0.07965902 0.08208500  l(t = matrix(45:50, ncol = 1), alpha = -4, beta = 0.03)  #>            [,1] #> [1,] 0.07065121 #> [2,] 0.07280286 #> [3,] 0.07502004 #> [4,] 0.07730474 #> [5,] 0.07965902 #> [6,] 0.08208500 l(t = 45, alpha = pop$alpha[1:5], beta = pop$beta[1:5])  #> [1] 0.04943966 0.06380303 0.05296605 0.03496243 0.06470944 l(t = matrix(c(45, 50, 45, 47.4, 30), ncol = 1), alpha = pop$alpha[1:5], beta = pop$beta[1:5])  #>            [,1] #> [1,] 0.04943966 #> [2,] 0.07494128 #> [3,] 0.05296605 #> [4,] 0.03691928 #> [5,] 0.04142702 t_mat <- matrix(c(45, 50, 45, 47.4, 30,                 45.1, 50.1, 45.5, 47.8, 38,                 48, 52.7, 60.1, 70.1, 99.9), ncol = 3, byrow = TRUE); t_mat #>      [,1] [,2] [,3] #> [1,] 45.0 50.0 45.0 #> [2,] 47.4 30.0 45.1 #> [3,] 50.1 45.5 47.8 #> [4,] 38.0 48.0 52.7 #> [5,] 60.1 70.1 99.9  l(t = t_mat, alpha = pop$alpha[1:5], beta = pop$beta[1:5])  #>            [,1]       [,2]       [,3] #> [1,] 0.04943966 0.05719509 0.04943966 #> [2,] 0.06892608 0.03937330 0.06400868 #> [3,] 0.06145926 0.05374399 0.05747231 #> [4,] 0.02982757 0.03742537 0.04163741 #> [5,] 0.10137780 0.13647889 0.33101750 t_mat <- matrix(rep(c(45, 50, 55), each = K), ncol = 3, byrow = TRUE) l(t = t_mat)  |> head() #>            [,1]       [,2]       [,3] #> [1,] 0.04943966 0.04943966 0.04943966 #> [2,] 0.06380303 0.06380303 0.06380303 #> [3,] 0.05296605 0.05296605 0.05296605 #> [4,] 0.03496243 0.03496243 0.03496243 #> [5,] 0.06470944 0.06470944 0.06470944 #> [6,] 0.08214702 0.08214702 0.08214702"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"cumulative-intensity-function-lambdat","dir":"Articles","previous_headings":"Setup > Intensity, cumulative intensity, and inverse cumulative intensity functions","what":"Cumulative intensity function Λ(t)\\Lambda(t)","title":"Sampling log-linear times","text":"cumulative intensity function Λ(,t)=∫atλ(s)ds\\Lambda(, t) = \\int_a^t \\lambda(s) \\ \\textrm{d}s. matter choose lower limit integration definition Λ\\Lambda – lower limit cancels mathematics sampling algorithms. Thus free use lower limit (say 0) antiderivative λ()\\lambda() convenient (integration constant). slight abuse notation, define 0 lower integration limit write Λ(t):=Λ(0,t)=∫0tλ(s)ds{\\Lambda(t) := \\Lambda(0, t) = \\int_0^t \\lambda(s) \\ \\textrm{d}s}. log-linear intensity example, calculus yields Λ(t)=1β(eα+βt−eα)\\Lambda(t) = \\frac{1}{\\beta} (e^{\\alpha + \\beta t} - e^\\alpha). vectorized version Λ\\Lambda example ","code":"L <- function(t, alpha = pop$alpha, beta = pop$beta, ...) {   (exp(alpha + beta * t) - exp(alpha)) / beta }"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"inverse-cumulative-intensity-function-lambda-1z","dir":"Articles","previous_headings":"Setup > Intensity, cumulative intensity, and inverse cumulative intensity functions","what":"Inverse cumulative intensity function Λ−1(z)\\Lambda^{-1}(z)","title":"Sampling log-linear times","text":"construction, Λ\\Lambda strictly positive monotone function tt, thus invertible. inverse cumulative intensity function Λ−1\\Lambda^{-1} defined function recovers tt pass Λ(t)\\Lambda(t). definition satisfies Λ−1(Λ(t))=t{\\Lambda^{-1} \\big ( \\Lambda(t) \\big ) = t}. example, Λ−1(z)=(log(βz+eα)−α)/β\\Lambda^{-1}(z) = \\big(\\log(\\beta z + e^\\alpha) - \\alpha\\big)/\\beta, easily derived formula Λ(t)\\Lambda(t). vectorized implementation Λ−1\\Lambda^{-1} example ","code":"Li <- function(z, alpha = pop$alpha, beta = pop$beta, ...) {   (log(beta * z + exp(alpha)) - alpha) / beta }"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"method-1-non-vectorized-sampling-with-nhpppdraw_sc_loglinear","dir":"Articles","previous_headings":"","what":"Method 1: non-vectorized sampling with nhppp::draw_sc_loglinear()","title":"Sampling log-linear times","text":"nhppp package function draw_sc_loglinear() draws times log-linear densities person time. slower methods, can practical even sizeable simulations run (e.g., statistical simulation analyses) develop code. ’s arguments alpha, beta name parameters log-linear intensity function λ\\lambda. range_t argument asks bounds interval [Tk0,Tk1)[T_{k0}, T_{k1}). argument atmost1 asks first time. special case function uses bespoke inversion algorithm.","code":"tictoc::tic(\"Method 1 (nonvectorized)\") t_nonvec_special_case <- rep(NA, K) for (k in 1:K) {   t1 <- nhppp::draw_sc_loglinear(     alpha = pop$alpha[k],      beta = pop$beta[k],      range_t = c(pop$T0[k], pop$T1[k]),      atmost1 = TRUE)   if(length(t1) != 0) {     t_nonvec_special_case[k] <- t1   } } tictoc::toc(log = TRUE) #> Method 1 (nonvectorized): 1.77 sec elapsed pop[, t_nonvec_special_case := t_nonvec_special_case]"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"method-2-vectorized-sampling-using-only-lambda","dir":"Articles","previous_headings":"","what":"Method 2: Vectorized sampling using only λ()\\lambda()","title":"Sampling log-linear times","text":"know intensity function λ\\lambda, nhppp employs thinning algorithm. One items needed thinning algorithm piecewise constant majorizer function λ*\\lambda_* : λ*(t)>=λ(t)\\lambda_*(t) >= \\lambda(t) tt interest. nhppp::vdraw_intensity_step_regular_cpp function assumes provide majorizer function matrix (lambda_maj_matrix). create matrix, split simulation time (, age 40 age 100) MM equal-length intervals. person kk interval mm, element lambda_maj_matrix[k, m] records supremum λk\\lambda_k mm-th interval. supremum – algorithm efficient give least upper bound – practically, maximum λ(t)\\lambda(t) tt interval. monotone intensity functions, function example, maximum one interval’s bounds. left bound, λ\\lambda decreasing, right bound, λ\\lambda increasing. helper function nhppp generates majorizer matrix automatically monotone (possibly discontinuous) functions nonmonotone continuous Lipschitz functions (functions whose maximum slope bounded). Even case complex, able find supremum works. code samples vectorized fashion know λ()\\lambda(). creates majorizer matrix M=5M=5 intervals whole simulation horizon. specify [Tk0,Tk1)[T_{k0}, T_{k1}) intervals person via subinterval option. (atmostB option can useful speed sampling minimize memory needs one interested first event . smaller value, faster algorithm check specified small. example, atmostB = 5 fine – returns exact solutions; checked [shown]. want mess , use option. function may already fast enough needs).","code":"tictoc::tic(\"Method 2 (vectorized, thinning)\")  M <- 5  break_points <- seq.int(from = 40, to = 100, length.out = M+1) breaks_mat <- matrix(rep(break_points, each = K), nrow = K)  lmaj_mat <- nhppp::get_step_majorizer(   fun = l,    breaks = breaks_mat,    is_monotone = TRUE)  pop[,     t_thinning := nhppp::vdraw_intensity_step_regular_cpp(       lambda = l,       lambda_maj_matrix = lmaj_mat,       range_t = c(40, 100),       subinterval =  matrix(c(pop$T0, pop$T1), ncol = 2, byrow = FALSE),       atmost1 = TRUE,        atmostB = 5       ) ] tictoc::toc(log = TRUE) # timer end #> Method 2 (vectorized, thinning): 0.114 sec elapsed"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"method-3-vectorized-sampling-using-lambda-and-lambda-1","dir":"Articles","previous_headings":"","what":"Method 3: Vectorized sampling using Λ()\\Lambda() and Λ−1()\\Lambda^{-1}()","title":"Sampling log-linear times","text":"efficient sampling possible one knows Λ()\\Lambda() Λ−1()\\Lambda^{-1}(). nhppp package can sample case using vdraw_cumulative_intensity() function. range_t matrix information person’s [Tk0,Tk1)[T_{k0}, T_{k1}).","code":"tictoc::tic(\"Method 3 (inversion)\")  range_t <- matrix(c(pop$T0, pop$T1), ncol = 2, byrow = FALSE) pop[,     t_inversion := nhppp::vdraw_cumulative_intensity(       Lambda = L,       Lambda_inv = Li,        range_t = range_t,       atmost1 = TRUE     ) ] tictoc::toc(log  = TRUE) # timer end #> Method 3 (inversion): 0.017 sec elapsed"},{"path":[]},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"simulation-time-costs","dir":"Articles","previous_headings":"Comparisons","what":"Simulation time-costs","title":"Sampling log-linear times","text":"Method 1 (nonvectorized): 1.77 sec elapsed. slowest approach – still bad 10510^{5} samples! Method 2 (vectorized, thinning): 0.114 sec elapsed. approach many times faster first approach. flexible – can accommodate complex time varying intensity functions. almost always know λ\\lambda can get majorizer λ*\\lambda_* easily fast. Method 3 (inversion): 0.017 sec elapsed. approach many times faster second one, requires implementations Λ\\Lambda Λ−1\\Lambda^{-1}.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"simulated-times","dir":"Articles","previous_headings":"Comparisons","what":"Simulated times","title":"Sampling log-linear times","text":"three methods sample correctly specified log-linear process. approximation play. QQ plots comparing simulated times three methods – good agreement population size K=105K = 10^{5}. KK increases agreement remains evidently excellent. done -depth comparisons elsewhere. set QQ plots suffice .","code":"qqplot(pop$t_nonvec_special_case, pop$t_thinning) qqplot(pop$t_nonvec_special_case, pop$t_inversion)"},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Sampling log-linear times","text":"Thanks Carolyn Rutter Hui Hsuan Chan providing numerical example use vignette.","code":""},{"path":"https://bladder-ca.github.io/nhppp/articles/Log_linear_times.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Sampling log-linear times","text":"Trikalinos TA, Sereda Y. nhppp: Simulating Nonhomogeneous Poisson Point Processes R. arXiv preprint arXiv:2402.00358. 2024 Feb 1.","code":""},{"path":"https://bladder-ca.github.io/nhppp/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thomas Trikalinos. Author, maintainer, copyright holder. Yuliia Sereda. Author.","code":""},{"path":"https://bladder-ca.github.io/nhppp/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Trikalinos TA, Sereda Y (2024). nhppp: Simulating Nonhomogeneous Poisson Point Processes R.","code":"@Manual{,   title = {nhppp: Simulating Nonhomogeneous Poisson Point Processes in R},   author = {Thomas A. Trikalinos and Yuliia Sereda},   year = {2024}, }"},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"nhppp-","dir":"","previous_headings":"","what":"Simulating Nonhomogeneous Poisson Point Processes","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"nhppp package simulating events one dimensional nonhomogeneous Poisson point processes (NHPPPs). functions based three algorithms provably sample target NHPPP: time-transformation homogeneous Poisson process (intensity one) via inverse integrated intensity function; generation Poisson number order statistics fixed density function; thinning majorizing NHPPP via acceptance-rejection scheme. developed provide fast memory efficient functions discrete event statistical simulations. description algorithms numerical comparison R packages, see Trikalinos Sereda (2024), accessible https://arxiv.org/abs/2402.00358.","code":""},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"can install release version nhppp CRAN : can install development version nhppp GitHub :","code":"install.packages(\"nhppp\") # install.packages(\"devtools\") devtools::install_github(\"bladder-ca/nhppp\")"},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"examples use generic function draw(), wrapper packages specific functions. draw() non-vectorized function, nhppp includes vectorized functions fast small memory footprint. Consider time varying intensity function λ(t)=e(0.2t)(1+sint)\\lambda(t) = e^{(0.2t)} (1 + \\sin t), sinusoidal intensity function exponential amplitude. draw samples interval (0,6π](0, 6\\pi] execute lambda_maj majorizer constant. available, integrated intensity function Λ(t)=∫0tλ(s)ds\\Lambda(t) = \\int_0^t \\lambda(s) \\ ds inverse Λ−1(z)\\Lambda^{-1}(z) result faster simulation times. example, Λ(t)=e0.2t(0.2sint−cost)+11.04+e0.2t−10.2\\Lambda(t) = \\frac{e^{0.2t}(0.2 \\sin t - \\cos t)+1}{1.04} + \\frac{e^{0.2t} - 1}{0.2}; Λ−1(z)\\Lambda^{-1}(z) constructed numerically upfront (can calculated numerically function, computational cost).","code":"l <- function(t) (1 + sin(t)) * exp(0.2 * t) nhppp::draw(lambda = l, lambda_maj = l(6 * pi), range_t = c(0, 6 * pi)) |>   head(n = 20) #>  [1] 1.197587 1.238620 1.497499 1.713629 1.761914 2.256739 2.537528 3.622938 #>  [9] 5.822574 6.064265 6.645696 6.651551 6.684603 6.875765 6.891348 7.130680 #> [17] 7.446557 7.453139 7.545474 7.557381 L <- function(t) {   exp(0.2 * t) * (0.2 * sin(t) - cos(t)) / 1.04 +     exp(0.2 * t) / 0.2 - 4.038462 } Li <- stats::approxfun(x = L(seq(0, 6 * pi, 10^-3)), y = seq(0, 6 * pi, 10^-3), rule = 2)  nhppp::draw(Lambda = L, Lambda_inv = Li, range_t = c(0, 6 * pi)) |>   head(n = 20) #>  [1] 0.01152846 0.23558627 0.32924742 0.49921843 0.63509297 1.36677413 #>  [7] 2.38941548 3.19511655 3.28049866 4.62140995 5.96916564 6.37504015 #> [13] 6.68283108 6.76577784 7.12919141 7.29249262 7.38665270 7.92953383 #> [19] 7.94791744 7.96591106"},{"path":"https://bladder-ca.github.io/nhppp/index.html","id":"function-naming-conventions","dir":"","previous_headings":"","what":"Function naming conventions","title":"Simulating Nonhomogeneous Poisson Point Processes","text":"functions whose name start ppp ztppp sample constant piecewise constant intensity functions, described : Functions whose names start ppp_[sequential|orderstats] sample event times interval constant intensity functions sequential order statistics algorithms. Function ztppp() samples one event times interval constant intensity, .e., zero-truncated Poisson process. Functions ppp_n() ppp_next_n() sample n events interval next n event times time t0. functions whose name starts draw vdraw sample NHPPPs. Functions names starting draw_zt sample least one event interval, .e., zero-truncated NHPPP. Functions names starting [draw|draw_zt]_intensity[_majorizer] expect intensity argument. third part ([_majorizer]) denotes , , majorizer function used. Functions names starting [draw|draw_zt]_cumulative_intensity[_algorithm] expect cumulative (integrated) intensity argument. third part ([_algorithm]) denotes algorithm used, one algorithms pertinent. Functions names starting vdraw vectorized.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_exp_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Definite integral of l = exp(alpha + beta*t) at time t with L(t0) = 0 — Lambda_exp_form","title":"Definite integral of l = exp(alpha + beta*t) at time t with L(t0) = 0 — Lambda_exp_form","text":"Definite integral l = exp(alpha + beta*t) starting t0 – l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_exp_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Definite integral of l = exp(alpha + beta*t) at time t with L(t0) = 0 — Lambda_exp_form","text":"","code":"Lambda_exp_form(t, alpha, beta, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_exp_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Definite integral of l = exp(alpha + beta*t) at time t with L(t0) = 0 — Lambda_exp_form","text":"t (double) time point alpha (double) intercept beta (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_exp_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse of the definite integral of l = exp(alpha + beta*t) at time t — Lambda_inv_exp_form","title":"Inverse of the definite integral of l = exp(alpha + beta*t) at time t — Lambda_inv_exp_form","text":"Inverse definite integral l = exp(alpha + beta*t) l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_exp_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse of the definite integral of l = exp(alpha + beta*t) at time t — Lambda_inv_exp_form","text":"","code":"Lambda_inv_exp_form(z, alpha, beta, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_exp_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse of the definite integral of l = exp(alpha + beta*t) at time t — Lambda_inv_exp_form","text":"z (double) value integrated rate want find time alpha (double) intercept beta (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_linear_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse of the definite integral of l = alpha + beta*t at time t — Lambda_inv_linear_form","title":"Inverse of the definite integral of l = alpha + beta*t at time t — Lambda_inv_linear_form","text":"Inverse definite integral l = alpha + beta*t l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_linear_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse of the definite integral of l = alpha + beta*t at time t — Lambda_inv_linear_form","text":"","code":"Lambda_inv_linear_form(z, alpha, beta, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_inv_linear_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse of the definite integral of l = alpha + beta*t at time t — Lambda_inv_linear_form","text":"z (double) value integrated rate want find time alpha (double) intercept beta (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_linear_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Definite integral of l = alpha + beta*t at time t with L(t0) = 0 — Lambda_linear_form","title":"Definite integral of l = alpha + beta*t at time t with L(t0) = 0 — Lambda_linear_form","text":"Definite integral l = alpha + beta*t starting t0 – l+.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_linear_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Definite integral of l = alpha + beta*t at time t with L(t0) = 0 — Lambda_linear_form","text":"","code":"Lambda_linear_form(t, alpha, beta, t0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/Lambda_linear_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Definite integral of l = alpha + beta*t at time t with L(t0) = 0 — Lambda_linear_form","text":"t (double) time point alpha (double) intercept beta (double) slope t0 (double) starting time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"Standard checks matrix ordered times (event series rows, times columns). Check times columns sorted, unique values [t_min, t_max], length size (applicable).","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"","code":"check_ppp_sample_validity(   times,   t_min,   t_max = NULL,   size = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"times (vector, double | matrix) times checked vectors matrices (time-vectors rows) t_min (double | vector) start time nterval t_max (double| vector) optional: end time interval; vector, length match number rows times. size (double) optional: size vector atmost1 (boolean) optional: one sample returned atleast1 (boolean) optional: least one sample returned","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_sample_validity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the validity of ppp samples arranged in matrix format — check_ppp_sample_validity","text":"None","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the validity of a ppp vector. — check_ppp_vector_validity","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"Standard checks vector ordered times. Check times vector sorted, unique values, values [t_min, t_max], length size (applicable).","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"","code":"check_ppp_vector_validity(   times,   t_min,   t_max = NULL,   size = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"times (vector, double) times checked t_min (double) start time nterval t_max (double) optional: end time interval size (double) optional: size vector atmost1 (boolean) optional: one sample returned atleast1 (boolean) optional: least one sample returned","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/check_ppp_vector_validity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the validity of a ppp vector. — check_ppp_vector_validity","text":"None","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"Compare deciles two vectors absolute difference average ratios less threshold","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"","code":"compare_ppp_vectors(ppp1, ppp2, threshold = 0.15, showQQ = TRUE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"ppp1 (vector, double) first vector ppp2 (vector, double) second vector threshold (double) optional: cutoff large absolute threshold showQQ (boolean) optional: show QQ plot absolute value Difference vs Average ratio decile bigger threshold","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/compare_ppp_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that two ppp vectors Q-Q agree — compare_ppp_vectors","text":"None","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"wrapper package's specific functions, thus somewhat slower. time-intensive simulations prefer one specific functions.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"","code":"draw(   lambda = NULL,   lambda_maj = NULL,   Lambda = NULL,   Lambda_inv = NULL,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"lambda (function) instantaneous rate NHPPP. continuous function time. lambda_maj (double, vector) intercept optional slope majorizing linear (exp_maj = FALSE) log-linear (exp_maj = TRUE) function range_t. Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() range_t (vector, double) min max time interval. rng_stream (rstream) rstream object NULL atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time interval","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function. — draw","text":"vector event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"Sample NHPPP times using inversion method, optionally using rstream generator object","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"","code":"draw_cumulative_intensity_inversion(   Lambda,   Lambda_inv = NULL,   range_t = c(0, 10),   range_L = c(Lambda(range_t[1]), Lambda(range_t[2])),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() range_t (vector, double) min max time interval range_L (vector, double) min max transformed time interval rng_stream (rstream) rstream object. atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_inversion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — draw_cumulative_intensity_inversion","text":"","code":"x <- draw_cumulative_intensity_inversion(Lambda = function(t) t + cos(t) - 1)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"Sample NHPPP times using order statistics method, optionally using rstream generator object.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"","code":"draw_cumulative_intensity_orderstats(   Lambda,   Lambda_inv = NULL,   range_t = c(0, 10),   range_L = c(Lambda(range_t[1]), Lambda(range_t[2])),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() range_t (vector, double) min max time interval range_L (vector, double) min max transformed time interval rng_stream (rstream) rstream object NULL. atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_cumulative_intensity_orderstats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (order statistics method) — draw_cumulative_intensity_orderstats","text":"","code":"x <- draw_cumulative_intensity_orderstats(Lambda = function(t) t + cos(t) - 1)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity","text":"Sample NHPPP times using thinning method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity","text":"","code":"draw_intensity(   lambda,   lambda_maj = NULL,   exp_maj = FALSE,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity","text":"lambda (function) instantaneous rate NHPPP. continuous function time. lambda_maj (double, vector) intercept optional slope majorizing linear (exp_maj = FALSE) log-linear (exp_maj = TRUE) function range_t. exp_maj (boolean) TRUE majorizer exp(alpha + beta * t) range_t (vector, double) min max time interval. rng_stream (rstream) rstream object NULL atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) — draw_intensity","text":"","code":"x <- draw_intensity(lambda = function(t) 1 + sin(t))"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"Sample NHPPP times using thinning method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"","code":"draw_intensity_step(   lambda,   lambda_maj_vector = lambda(1:10),   times_vector = 0:10,   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"lambda (function) instantaneous rate NHPPP. continuous function time. lambda_maj_vector (scalar, double) K constant majorizing rates, one per interval times_vector (vector, double) K+1 time points defining K intervals constant rates: [t_1 = range_t[1],       t_2): first interval [t_k,                t_{k+1}): k-th interval [t_{K}, t_{K+1} = range_t[2]): K-th (last) interval rng_stream (rstream) rstream object NULL atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_intensity_step.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — draw_intensity_step","text":"","code":"x <- draw_intensity_step(lambda = function(t) exp(.02 * t))"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"Sample NHPPP times linear intensity function using inversion method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"","code":"draw_sc_linear(   alpha = 1,   beta = 0,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"alpha (double) intercept beta (double) slope range_t (vector, double) min max time interval rng_stream (rstream) rstream object. atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with linear intensity function (inversion method) — draw_sc_linear","text":"","code":"x <- draw_sc_linear(alpha = 0, beta = 0.2)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":null,"dir":"Reference","previous_headings":"","what":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"Sample NHPPP times log linear intensity function using inversion method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"","code":"draw_sc_loglinear(   alpha = 1,   beta = 0,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"alpha (double) intercept exponent beta (double) slope exponent range_t (vector, double) min max time interval rng_stream (rstream) rstream object. atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_loglinear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) with log-linear intensity function (inversion method) — draw_sc_loglinear","text":"","code":"x <- draw_sc_loglinear(alpha = 0, beta = 0.2)"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals need length.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"","code":"draw_sc_step(   lambda_vector = rep(1, 5),   times_vector = c(0:5),   rng_stream = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"lambda_vector (scalar, double) K constant rates, one per interval times_vector (vector, double) K+1 time points defining K intervals constant rates: [t_1 = range_t[1],       t_2): first interval [t_k,                t_{k+1}): k-th interval [t_{K}, t_{K+1} = range_t[2]): K-th (last) interval rng_stream rstream object atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a piecewise constant-rate Poisson Point Process over (t_min, t_max] (inversion method) The intervals need not have the same length. — draw_sc_step","text":"","code":"x <- draw_sc_step(lambda_vector = rep(1, 5), times_vector = c(0:5))"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"Sampling NHPPPs piecewise constant intensities interval lengths (non-vectorized)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"","code":"draw_sc_step_regular(   Lambda_vector = NULL,   lambda_vector = NULL,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE,   atleast1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"Lambda_vector (scalar, double) K integrated intensity rates end interval lambda_vector (scalar, double) K constant intensity rates, one per interval range_t (vector, double) t_min t_max rng_stream rstream object atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/draw_sc_step_regular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sampling from NHPPPs with piecewise constant intensities with same interval lengths (non-vectorized) — draw_sc_step_regular","text":"","code":"x <- draw_sc_step_regular(Lambda_vector = 1:5, range_t = c(0, 5))"},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper functions — expect_no_error","title":"Helper functions — expect_no_error","text":"helper function augments test_that::expect_no_error() expect error. Copied R6 source code.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper functions — expect_no_error","text":"","code":"expect_no_error(expr)"},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper functions — expect_no_error","text":"expr Expression.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/expect_no_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Helper functions — expect_no_error","text":"Small utility functions. exported user.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"Return piecewise constant (step) majorizer K-Lipschitz functions interval. function vectorized breaks argument.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"","code":"get_step_majorizer(fun, breaks, is_monotone = TRUE, K = 0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"fun function object single argument x. x matrix, fun vectorized . breaks (vector matrix) set M+1 boundaries M subintervals x. breaks matrix, row treated separate set breaks. is_monotone (boolean) function monotone? (Default TRUE.) K (double) non-negative number Lipschitz cone. (Default 0.)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"vector length M values piecewise constant majorizer","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/get_step_majorizer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise constant (step) majorizer for K-Lipschitz functions over an interval (vectorized over the breaks argument). — get_step_majorizer","text":"","code":"get_step_majorizer(fun = abs, breaks = -5:5, is_monotone = FALSE, K = 1) #>  [1] 5.5 4.5 3.5 2.5 1.5 1.5 2.5 3.5 4.5 5.5"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"Numerically evaluate inverse function specific point","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"","code":"inverse_with_uniroot(   f = f,   y,   min_x = 0,   max_x = 1,   min_y = f(min_x),   max_y = f(max_x) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"f (function) function inverted; must continuous increasing y (scalar, double) f(x)=y value evaluate inverse min_x (scalar, double) min domain f() max_x (scalar, double) max domain f() min_y (scalar, double) min range f() max_y (scalar, double) max range f()","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"(scalar, double) vector x=f^(-1)(y): inverted value","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerically evaluate the inverse of a function at a specific point — inverse_with_uniroot","text":"","code":"inverse_with_uniroot(f = function(x) {   2 * x }, y = 0.5) #> [1] 0.25"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"Numerically evaluate inverse monotonically increasing continuous function R R specific points.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"","code":"inverse_with_uniroot_sorted(   f,   y,   range_x = c(0, 10),   range_y = c(f(range_x[1]), f(range_x[2])) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"f (function) function inverted; must continuous increasing y (vector, double) f(x)=y values evaluate inverse; must ascending order range_x (vector, double) min max domain f() range_y (vector, double) min max range f()","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"(vector, double) vector x=f^(-1)(y): inverted values","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/inverse_with_uniroot_sorted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerically evaluate the inverse of a monotonically increasing continuous function from R to R at specific points. — inverse_with_uniroot_sorted","text":"","code":"inverse_with_uniroot_sorted(f = function(x) {   2 * x }, y = c(0, 0.5)) #> [1] 0.00 0.25"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"Helper function vectorized versions sampling functions. Takes usual ways lambda_mat Lambda_mat specified returns Lambda_mat.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"","code":"make_cumulative_Lambda_matrix(   Lambda_mat = NULL,   lambda_mat = NULL,   interval_duration = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"Lambda_mat matrix cumulative intensities missing lambda_mat matrix intensities missing interval_duration vector number elements rows Lambda_mat","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_cumulative_Lambda_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns Lambda_mat. — make_cumulative_Lambda_matrix","text":"matrix (r x 2), row-expanded needed","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"Helper function vectorized versions sampling functions. Takes usual ways lambda_mat Lambda_mat specified returns lambda_mat.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"","code":"make_lambda_matrix(   lambda_mat = NULL,   Lambda_mat = NULL,   interval_duration = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"lambda_mat matrix intensities missing Lambda_mat matrix cumulative intensities missing interval_duration vector number elements rows Lambda_mat","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_lambda_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that lambda_mat and Lambda_mat are specified and returns lambda_mat. — make_lambda_matrix","text":"matrix (r x 2), row-expanded needed","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"Helper function vectorized versions sampling functions. Takes usual ways range_t specified (2-vector, 1 x 2 r x 2 matrix) returns r x 2 matrix.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"","code":"make_range_t_matrix(range_t, n_rows)"},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"range_t 2-vector, 1 x 2 r x 2 matrix n_rows number rows fully expanded matrix (r)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/make_range_t_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for the vectorized versions of sampling functions. Takes the usual ways that range_t is specified (a 2-vector, a 1 x 2 or an r x 2 matrix) and returns a r x 2 matrix. — make_range_t_matrix","text":"matrix (r x 2), row-expanded needed","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"Return matrix column-wise cumulative sum checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"","code":"mat_cumsum_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"X (matrix)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise cumulative sum No checks for arguments is done. — mat_cumsum_columns","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"Return matrix column-wise cumulative sum replacing cells larger ceil NA. checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"","code":"mat_cumsum_columns_with_scalar_ceiling(X, ceil = Inf)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"X (matrix) ceil (double Inf) ceiling applied","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_scalar_ceiling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_scalar_ceiling","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"Return matrix column-wise cumulative sum replacing cells larger ceil NA. checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"","code":"mat_cumsum_columns_with_vector_ceiling(X, ceil = Inf)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"X (matrix) ceil (vector Inf) set ceilings applied, per row X","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_cumsum_columns_with_vector_ceiling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise cumulative sum replacing cells larger than ceil with NA. No checks for arguments is done. — mat_cumsum_columns_with_vector_ceiling","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"Return matrix column-wise differencing. checks arguments done.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"","code":"mat_diff_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"X (matrix)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/mat_diff_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return matrix with column-wise differencing. No checks for arguments is done. — mat_diff_columns","text":"matrix","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_cumsum_columns( X ) — matrix_cumsum_columns","title":"Usage: matrix_cumsum_columns( X ) — matrix_cumsum_columns","text":"Usage: matrix_cumsum_columns( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_cumsum_columns( X ) — matrix_cumsum_columns","text":"","code":"matrix_cumsum_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns_inplace.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_cumsum_columns_inplace( X ) — matrix_cumsum_columns_inplace","title":"Usage: matrix_cumsum_columns_inplace( X ) — matrix_cumsum_columns_inplace","text":"Usage: matrix_cumsum_columns_inplace( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_cumsum_columns_inplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_cumsum_columns_inplace( X ) — matrix_cumsum_columns_inplace","text":"","code":"matrix_cumsum_columns_inplace(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_diff_columns( X ) — matrix_diff_columns","title":"Usage: matrix_diff_columns( X ) — matrix_diff_columns","text":"Usage: matrix_diff_columns( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_diff_columns( X ) — matrix_diff_columns","text":"","code":"matrix_diff_columns(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns_inplace.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage: matrix_diff_columns_inplace( X ) — matrix_diff_columns_inplace","title":"Usage: matrix_diff_columns_inplace( X ) — matrix_diff_columns_inplace","text":"Usage: matrix_diff_columns_inplace( X )","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/matrix_diff_columns_inplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Usage: matrix_diff_columns_inplace( X ) — matrix_diff_columns_inplace","text":"","code":"matrix_diff_columns_inplace(X)"},{"path":"https://bladder-ca.github.io/nhppp/reference/nhppp-package.html","id":null,"dir":"Reference","previous_headings":"","what":"nhppp: Simulating Nonhomogeneous Poisson Point Processes — nhppp-package","title":"nhppp: Simulating Nonhomogeneous Poisson Point Processes — nhppp-package","text":"Simulates events one dimensional nonhomogeneous Poisson point processes (NHPPPs) per Trikalinos Sereda (2024, doi:10.48550/arXiv.2402.00358 ). Functions based three algorithms provably sample target NHPPP: time-transformation homogeneous Poisson process (intensity one) via inverse integrated intensity function (Cinlar E, \"Theory stochastic processes\" (1975, ISBN:0486497996)); generation Poisson number order statistics fixed density function; thinning majorizing NHPPP via acceptance-rejection scheme (Lewis PAW, Shedler, GS (1979) doi:10.1002/nav.3800260304 ).","code":""},{"path":[]},{"path":"https://bladder-ca.github.io/nhppp/reference/nhppp-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"nhppp: Simulating Nonhomogeneous Poisson Point Processes — nhppp-package","text":"Maintainer: Thomas Trikalinos thomas_trikalinos@brown.edu (ORCID) [copyright holder] Authors: Yuliia Sereda sereda_yuliia@brown.edu (ORCID)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"Simulate specific number points homogeneous Poisson Point Process (t_min, t_max]","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"","code":"ppp_n(size, range_t = c(0, 10), rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"size (int) number points simulated range_t (vector, double) min max time interval rng_stream rstream object","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"vector event times size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max] — ppp_n","text":"","code":"x <- ppp_n(size = 10, range_t = c(0, 10))"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"Simulate n events homogeneous Poisson Point Process.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"","code":"ppp_next_n(n = 1, rate = 1, t_min = 0, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"n scalar number samples rate scalar instantaneous rate t_min scalar starting time value rng_stream rstream object","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"vector event times t (starting t_min)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_next_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate n events from a homogeneous Poisson Point Process. — ppp_next_n","text":"","code":"x <- ppp_next_n(n = 10, rate = 1, t_min = 0)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"Simulate homogeneous Poisson Point Process (t_min, t_max] (order statistics method)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"","code":"ppp_orderstat(range_t = c(0, 10), rate = 1, rng_stream = NULL, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"range_t (vector, double) min max time interval rate (scalar, double) constant instantaneous rate rng_stream rstream object atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_orderstat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method) — ppp_orderstat","text":"","code":"x <- ppp_orderstat(range_t = c(0, 10), rate = 1)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"Simulate homogeneous Poisson Point Process (t_min, t_max]","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"","code":"ppp_sequential(   range_t = c(0, 10),   rate = 1,   tol = 10^-6,   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"range_t (vector, double) min max time interval rate (scalar, double) constant instantaneous rate tol probability drawn events (t_min, t_max] rng_stream rstream object atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ppp_sequential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a homogeneous Poisson Point Process over (t_min, t_max] — ppp_sequential","text":"","code":"x <- ppp_sequential(range_t = c(0, 10), rate = 1, tol = 10^-6)"},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":null,"dir":"Reference","previous_headings":"","what":"Read code from text file as string — read_code","title":"Read code from text file as string — read_code","text":"Read code text file string","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read code from text file as string — read_code","text":"","code":"read_code(codeFile)"},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read code from text file as string — read_code","text":"codeFile Path file","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/read_code.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read code from text file as string — read_code","text":"codeFile contents character string","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential random samples from rstream objects — rng_stream_rexp","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"","code":"rng_stream_rexp(size = 1, rate = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"size Integer, number samples rate Positive number, rate (.e., 1/mean) rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"vector exponential variates size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential random samples from rstream objects — rng_stream_rexp","text":"","code":"rng_stream_rexp(10) #>  [1] 1.26415490 1.39129122 0.05221346 0.68832679 1.47422373 1.19901650 #>  [7] 0.74638177 0.70668105 2.15928468 0.76381420"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":null,"dir":"Reference","previous_headings":"","what":"Poisson random samples from rstream objects — rng_stream_rpois","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"","code":"rng_stream_rpois(size = 1, lambda = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"size Integer, number samples lambda Positive number, mean rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"vector counts size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rpois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Poisson random samples from rstream objects — rng_stream_rpois","text":"","code":"rng_stream_rpois(10) #>  [1] 1 1 0 1 3 1 2 0 2 2"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform random samples from rstream objects — rng_stream_runif","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"","code":"rng_stream_runif(size = 1, minimum = 0, maximum = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"size Integer, number samples minimum Lower bound maximum Upper bound rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"vector uniform variates size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_runif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform random samples from rstream objects — rng_stream_runif","text":"","code":"rng_stream_runif(10) #>  [1] 0.72576396 0.36732902 0.52342842 0.46987891 0.09856639 0.51603491 #>  [7] 0.44973383 0.54946155 0.64950619 0.15903483"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":null,"dir":"Reference","previous_headings":"","what":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"Sample rstream objects","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"","code":"rng_stream_rztpois(size = 1, lambda = 1, rng_stream = NULL)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"size Integer, number samples lambda Positive number, mean original (untruncated) Poisson distribution rng_stream (rstream) rstream object NULL","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"vector non zero counts size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rng_stream_rztpois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zero-truncated Poisson random samples from rstream objects — rng_stream_rztpois","text":"","code":"rng_stream_rztpois(10) #>  [1] 1 3 2 2 1 1 1 2 1 1"},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":null,"dir":"Reference","previous_headings":"","what":"Zero-truncated Poisson random samples (basic R) — rztpois","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"Sample zero-truncated Poisson random samples (basic R)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"","code":"rztpois(size = 1, lambda = 1)"},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"size Integer, number samples lambda Positive number, mean original (untruncated) Poisson distribution","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"vector non zero counts size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/rztpois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zero-truncated Poisson random samples (basic R) — rztpois","text":"","code":"rztpois(10, 1) #>  [1] 1 2 1 1 2 2 1 1 2 1 rztpois(10, 1:10) #>  [1]  1  1  3  2  6  8  5 11 12  5"},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":null,"dir":"Reference","previous_headings":"","what":"Simpson's method to integrate a univariate function. — simpson_num_integr","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"Simpson's method integrate univariate continuous function. Faster R's integrate() precise enough, checks. error M (b-)^5/(180 n^4) M maximum fourth derivative integrand interval [, b].","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"","code":"simpson_num_integr(f, a, b, n)"},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"f function takes single argument lower limit integration b upper limit integration n integer, number integration points b","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/simpson_num_integr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simpson's method to integrate a univariate function. — simpson_num_integr","text":"numeric, integration value examples #expect 1 simpson_num_integr(sin, 0, pi/2, 100) #max error simpson_num_integr(sin, 0, pi/2, 100) 5.312842e-10 1 * (pi/2 - 0)^5/(180 * 100^4)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"wrapper package's specific functions, thus slightly slower. time-intensive simulations prefer one specific functions.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"","code":"vdraw(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   range_t = NULL,   tol = 10^-6,   atmost1 = FALSE,   atleast1 = FALSE,   use_cpp = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"lambda (function) vectorized intensity function, one two arguments. first time. optional second (named lambda_args) named list additional arguments. lambda_args (list) optional list named arguments lambda() Lambda_maj_matrix (matrix) majorizeintegrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval range_t (vector, matrix) t_min t_max, possibly vectorized tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time interval use_cpp boolean, use C++ code","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"vector event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized generic function for simulating from NHPPPs given the intensity function or the cumulative intensity function — vdraw","text":"","code":"Z <- vdraw(   lambda = function(x, lambda_args = NULL) 0.1 * x,   range_t = c(1, 10),   lambda_maj_matrix = matrix(rep(1, 5), nrow = 1),   atmost1 = FALSE, atleast1 = FALSE, use_cpp = TRUE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — vdraw_cumulative_intensity","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — vdraw_cumulative_intensity","text":"Sample NHPPP times using inversion method, optionally using rstream generator object","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — vdraw_cumulative_intensity","text":"","code":"vdraw_cumulative_intensity(   Lambda,   Lambda_inv,   Lambda_args = NULL,   Lambda_inv_args = NULL,   range_t = NULL,   tol = 10^-6,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — vdraw_cumulative_intensity","text":"Lambda (function, double vector) increasing function integrated rate NHPPP. shoudl take vectorized argument t times optional arguments list Lambda_inv (function, double vector) inverse Lambda(), also vectorized form Lambda_args (list) optional arguments pass Lambda Lambda_inv_args (list) optional arguments pass Lambda_inv() range_t (vector/matrix double) min max time interval. vecor 2 elements, assume 1 series points drawn. matrix, rows number point processes drawn. tol tolerange calulations atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_cumulative_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized simulation from a non homogeneous Poisson Point Process (NHPPP) from (t_min, t_max) (inversion method) — vdraw_cumulative_intensity","text":"vector event times (t_); events realize, vector length 0","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular","text":"Vectorized sampling non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular","text":"","code":"vdraw_intensity_step_regular(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   range_t = NULL,   subinterval = NULL,   tol = 10^-6,   atmost1 = FALSE,   atmostB = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular","text":"lambda (function) vectorized intensity function, one two arguments. first time. optional second named list additional arguments. lambda_args (list) optional list named arguments lambda() Lambda_maj_matrix (matrix) majorizeintegrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval range_t (vector, matrix) t_min t_max, possibly vectorized subinterval (matrix, double) subinterval range_t sample tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular","text":"","code":"Z <- vdraw_intensity_step_regular(   lambda = function(x, lambda_args = NULL) 0.1 * x,   range_t = c(1, 10),   lambda_maj_matrix = matrix(rep(1, 5), nrow = 1) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vdraw_intensity_step_regular_R","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vdraw_intensity_step_regular_R","text":"Vectorized sampling non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vdraw_intensity_step_regular_R","text":"","code":"vdraw_intensity_step_regular_R(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   range_t = NULL,   tol = 10^-6,   atmost1 = FALSE,   force_zt_majorizer = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vdraw_intensity_step_regular_R","text":"lambda (function) vectorized intensity function, one two arguments. first time. optional second named list additional arguments. lambda_args (list) optional list named arguments lambda() Lambda_maj_matrix (matrix) majorizeintegrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval range_t (vector, matrix) t_min t_max, possibly vectorized tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time force_zt_majorizer boolean, force use zero-truncated majorizer; - used flexibility calling functions. Keep default FALSE unless know . ... () arguments (ignored  – used flexibility calling functions)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vdraw_intensity_step_regular_R","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vdraw_intensity_step_regular_R","text":"","code":"Z <- vdraw_intensity_step_regular_R(   lambda = function(x, lambda_args = NULL) 0.1 * x,   range_t = c(1, 10),   lambda_maj_matrix = matrix(rep(1, 5), nrow = 1) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"Vectorized sampling non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"","code":"vdraw_intensity_step_regular_cpp(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   range_t = NULL,   subinterval = NULL,   tol = 10^-6,   atmost1 = FALSE,   atmostB = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"lambda (function) vectorized intensity function, one two arguments. first time. optional second named list additional arguments. lambda_args (list) optional list named arguments lambda() Lambda_maj_matrix (matrix) majorizeintegrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval range_t (vector, matrix) t_min t_max, possibly vectorized subinterval (matrix, double) subinterval range_t sample tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_intensity_step_regular_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from a non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (C++) — vdraw_intensity_step_regular_cpp","text":"","code":"Z <- vdraw_intensity_step_regular_cpp(   lambda = function(x, lambda_args = NULL) 0.1 * x,   range_t = c(1, 10),   lambda_maj_matrix = matrix(rep(1, 5), nrow = 1) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular","text":"","code":"vdraw_sc_step_regular(   Lambda_matrix = NULL,   lambda_matrix = NULL,   range_t = c(0, 10),   tol = 10^-6,   atmost1 = FALSE,   atleast1 = FALSE,   use_cpp = TRUE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular","text":"Lambda_matrix (matrix) integrated intensity rates end interval lambda_matrix (matrix) intensity rates, one per interval range_t (vector, double) t_min t_max tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atleast1 boolean, draw least 1 event time (zero-truncated NHPPP) use_cpp (boolean, TRUE) use C++ implementation function","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular","text":"","code":"x <- vdraw_sc_step_regular(Lambda_matrix = matrix(1:5, nrow = 1))"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular_R","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular_R","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular_R","text":"","code":"vdraw_sc_step_regular_R(   Lambda_matrix = NULL,   lambda_matrix = NULL,   range_t = c(0, 10),   tol = 10^-6,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular_R","text":"Lambda_matrix (matrix) integrated intensity rates end interval lambda_matrix (matrix) intensity rates, one per interval range_t (vector, double) t_min t_max tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular_R","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (R) — vdraw_sc_step_regular_R","text":"","code":"x <- vdraw_sc_step_regular_R(Lambda_matrix = matrix(1:5, nrow = 1))"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"","code":"vdraw_sc_step_regular_cpp(   lambda_matrix = NULL,   Lambda_matrix = NULL,   range_t = NULL,   subinterval = NULL,   tol = 10^-6,   atmost1 = FALSE,   atmostB = NULL )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"lambda_matrix (matrix) intensity rates, one per interval Lambda_matrix (matrix) integrated intensity rates end interval range_t (vector, double) t_min t_max subinterval (matrix, double) subinterval range_t sample tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time atmostB NULL, draw B (B>0) event times. NULL means ignore.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vdraw_sc_step_regular_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from NHPPPs with piecewise constant intensities with same interval lengths (C++) — vdraw_sc_step_regular_cpp","text":"","code":"x <- vdraw_sc_step_regular(Lambda_matrix = matrix(1:5, nrow = 1))"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity_step_regular","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity_step_regular","text":"Vectorized sampling zero-truncated non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity_step_regular","text":"","code":"vztdraw_intensity_step_regular(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   range_t = NULL,   tol = 10^-6,   atmost1 = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity_step_regular","text":"lambda (function) vectorized intensity function, one two arguments. first time. optional second named list additional arguments. lambda_args (list) optional list named arguments lambda() Lambda_maj_matrix (matrix) majorizeintegrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval range_t (vector, matrix) t_min t_max, possibly vectorized tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time ... () arguments (ignored  – used flexibility calling functions)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity_step_regular","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers — vztdraw_intensity_step_regular","text":"","code":"Z <- vztdraw_intensity_step_regular(   lambda = function(x, lambda_args = NULL) 0.1 * x,   range_t = c(1, 10),   lambda_maj_matrix = matrix(rep(1, 5), nrow = 1) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular_R","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular_R","text":"Vectorized sampling zero-truncated non homogeneous Poisson Point Process (NHPPP) interval (thinning method) piecewise constant_majorizers. majorizers step functions equal-length time intevals.","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular_R","text":"","code":"vztdraw_intensity_step_regular_R(   lambda = NULL,   lambda_args = NULL,   Lambda_maj_matrix = NULL,   lambda_maj_matrix = NULL,   range_t = NULL,   tol = 10^-6,   atmost1 = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular_R","text":"lambda (function) vectorized intensity function, one two arguments. first time. optional second named list additional arguments. lambda_args (list) optional list named arguments lambda() Lambda_maj_matrix (matrix) majorizeintegrated intensity rates end interval lambda_maj_matrix (matrix) intensity rates, one per interval range_t (vector, matrix) t_min t_max, possibly vectorized tol (scalar, double) tolerance number events atmost1 boolean, draw 1 event time ... () arguments (ignored  – used flexibility calling functions)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular_R","text":"matrix event times (columns) per draw (rows) NAs structural empty spots","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_intensity_step_regular_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from an interval (thinning method) with piecewise constant_majorizers (R) — vztdraw_intensity_step_regular_R","text":"","code":"Z <- vztdraw_intensity_step_regular_R(   lambda = function(x, lambda_args = NULL) 0.1 * x,   range_t = c(1, 10),   lambda_maj_matrix = matrix(rep(1, 5), nrow = 1) )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular","text":"","code":"vztdraw_sc_step_regular(   Lambda_matrix = NULL,   lambda_matrix = NULL,   range_t = c(0, 10),   subinterval = NULL,   atmost1 = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular","text":"Lambda_matrix (matrix) integrated intensity rates end interval lambda_matrix (matrix) intensity rates, one per interval range_t (vector, double) t_min t_max subinterval (vector, double) optional – subinterval range_t sample. NULL, whole range_t used. atmost1 boolean, draw 1 event time ... () arguments (ignored  – used flexibility calling functions)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths — vztdraw_sc_step_regular","text":"","code":"x <- vztdraw_sc_step_regular(Lambda_matrix = matrix(1:5, nrow = 1))"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (R) — vztdraw_sc_step_regular_R","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (R) — vztdraw_sc_step_regular_R","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (R) — vztdraw_sc_step_regular_R","text":"","code":"vztdraw_sc_step_regular_R(   Lambda_matrix = NULL,   lambda_matrix = NULL,   range_t = c(0, 10),   atmost1 = FALSE,   ... )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (R) — vztdraw_sc_step_regular_R","text":"Lambda_matrix (matrix) integrated intensity rates end interval lambda_matrix (matrix) intensity rates, one per interval range_t (vector, double) t_min t_max atmost1 boolean, draw 1 event time ... () arguments (ignored  – used flexibility calling functions)","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (R) — vztdraw_sc_step_regular_R","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (R) — vztdraw_sc_step_regular_R","text":"","code":"x <- vztdraw_sc_step_regular_R(Lambda_matrix = matrix(1:5, nrow = 1))"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (C++) — vztdraw_sc_step_regular_cpp","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (C++) — vztdraw_sc_step_regular_cpp","text":"Simulate piecewise constant-rate Poisson Point Process (t_min, t_max] (inversion method) intervals length (\"regular\").","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (C++) — vztdraw_sc_step_regular_cpp","text":"","code":"vztdraw_sc_step_regular_cpp(   Lambda_matrix = NULL,   lambda_matrix = NULL,   range_t = c(0, 10),   subinterval = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (C++) — vztdraw_sc_step_regular_cpp","text":"Lambda_matrix (matrix) integrated intensity rates end interval lambda_matrix (matrix) intensity rates, one per interval range_t (vector, double) t_min t_max subinterval (vector, double) optional – subinterval range_t sample. NULL, whole range_t used. atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (C++) — vztdraw_sc_step_regular_cpp","text":"vector event times t events realize, 0 length","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/vztdraw_sc_step_regular_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized sampling from zero-truncated NHPPPs with piecewise constant intensities with same interval lengths (C++) — vztdraw_sc_step_regular_cpp","text":"","code":"x <- vztdraw_sc_step_regular_cpp(Lambda_matrix = matrix(1:5, nrow = 1))"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"Sample zero-truncated NHPPP times using order statistics method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"","code":"ztdraw_cumulative_intensity(   Lambda,   Lambda_inv = NULL,   range_t = c(0, 10),   range_L = c(Lambda(range_t[1]), Lambda(range_t[2])),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"Lambda (function, double vector) continuous increasing R R map integrated rate NHPPP Lambda_inv (function, double vector) inverse Lambda() range_t (vector, double) min max time interval range_L (vector, double) min max transformed time interval rng_stream (rstream) rstream object NULL. atmost1 (boolean) draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_cumulative_intensity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) (order statistics method) — ztdraw_cumulative_intensity","text":"","code":"x <- ztdraw_cumulative_intensity(Lambda = function(t) t + cos(t) - 1)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity","text":"Sample zero-truncated NHPPP intensity times using thinning method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity","text":"","code":"ztdraw_intensity(   lambda,   lambda_maj = NULL,   exp_maj = FALSE,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity","text":"lambda (function) instantaneous rate NHPPP. continuous function time. lambda_maj (double, vector) intercept optional slope majorizing linear (exp_maj = FALSE) log-linear (exp_maj = TRUE) function range_t. exp_maj (boolean) TRUE majorizer exp(alpha + beta * t) range_t (vector, double) min max time interval. rng_stream (rstream) rstream object NULL atmost1 (boolean) draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t0, t_max) (thinning method) — ztdraw_intensity","text":"","code":"x <- ztdraw_intensity(lambda = function(t) 1 + sin(t))"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"Sample zero-truncated NHPPP times using thinning method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"","code":"ztdraw_intensity_step(   lambda,   lambda_maj_vector = lambda(1:10),   times_vector = 0:10,   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"lambda (function) instantaneous rate NHPPP. continuous function time. lambda_maj_vector (scalar, double) K constant majorizing rates, one per interval times_vector (vector, double) K+1 time points defining K intervals constant rates: [t_1 = range_t[1],       t_2): first interval [t_k,                t_{k+1}): k-th interval [t_{K}, t_{K+1} = range_t[2]): K-th (last) interval rng_stream (rstream) rstream object NULL atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"vector event times (t_) least one element","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_intensity_step.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from (t0, t_max) (thinning method) with piecewise constant_majorizer — ztdraw_intensity_step","text":"","code":"x <- ztdraw_intensity_step(lambda = function(t) exp(.02 * t))"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"Sample zero-truncated NHPPP times linear intensity function using inversion method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"","code":"ztdraw_sc_linear(   alpha = 1,   beta = 0,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"alpha (double) intercept beta (double) slope range_t (vector, double) min max time interval rng_stream (rstream) rstream object atmost1 (boolean) draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate size samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with linear intensity function — ztdraw_sc_linear","text":"","code":"x <- ztdraw_sc_linear(alpha = 0, beta = 0.2)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function (inversion method) — ztdraw_sc_loglinear","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function (inversion method) — ztdraw_sc_loglinear","text":"Sample zt-NHPPP times log-linear intensity function using inversion method, optionally using rstream generator","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function (inversion method) — ztdraw_sc_loglinear","text":"","code":"ztdraw_sc_loglinear(   alpha = 1,   beta = 0,   range_t = c(0, 10),   rng_stream = NULL,   atmost1 = FALSE )"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function (inversion method) — ztdraw_sc_loglinear","text":"alpha (double) intercept exponent beta (double) slope exponent range_t (vector, double) min max time interval rng_stream (rstream) rstream object. atmost1 boolean, 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function (inversion method) — ztdraw_sc_loglinear","text":"vector least 1 event times","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztdraw_sc_loglinear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from (t_min, t_max) with a log-linear intensity function (inversion method) — ztdraw_sc_loglinear","text":"","code":"x <- ztdraw_sc_loglinear(alpha = 0, beta = 0.2)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"Simulate zero-truncated homogeneous Poisson Point Process (t_min, t_max]","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"","code":"ztppp(range_t = c(0, 10), rate = 1, rng_stream = NULL, atmost1 = FALSE)"},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"range_t (vector, double) min max time interval rate (scalar, double) constant instantaneous rate rng_stream rstream object atmost1 boolean, draw 1 event time","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"vector event times size size","code":""},{"path":"https://bladder-ca.github.io/nhppp/reference/ztppp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max] — ztppp","text":"","code":"x <- ztppp(range_t = c(0, 10), rate = 0.001)"},{"path":[]},{"path":"https://bladder-ca.github.io/nhppp/news/index.html","id":"nhppp-014","dir":"Changelog","previous_headings":"","what":"nhppp 0.1.4","title":"nhppp 0.1.4","text":"CRAN release: 2024-05-28 Function arguments now consistent. extensive numerical checks. Added C++ code vectorized functions – computational speed memory efficiency.","code":""},{"path":"https://bladder-ca.github.io/nhppp/news/index.html","id":"nhppp-013","dir":"Changelog","previous_headings":"","what":"nhppp 0.1.3","title":"nhppp 0.1.3","text":"CRAN release: 2024-02-02 CRAN release","code":""},{"path":"https://bladder-ca.github.io/nhppp/news/index.html","id":"nhppp-012","dir":"Changelog","previous_headings":"","what":"nhppp 0.1.2","title":"nhppp 0.1.2","text":"Renamed functions start draw (instead nhppp_t), draw_zt (instead ztnhppp_t), vdraw (instead ending _vec()) Initial CRAN submission.","code":""}]
