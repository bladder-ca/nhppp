<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="es">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Sampling log-linear times • nhppp</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Sampling log-linear times">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">nhppp</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.3</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Log_linear_times.html">Sampling log-linear times</a></li>
    <li><a class="dropdown-item" href="../articles/Simple_des_model_cancer_natural_Hx.html">A simple discrete event simulation model of a cancer's natural history</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/bladder-ca/nhppp/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Sampling log-linear times</h1>
                        <h4 data-toc-skip class="author">TA
Trikalinos</h4>
            
            <h4 data-toc-skip class="date">2024-10-17</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/bladder-ca/nhppp/blob/main/vignettes/Log_linear_times.Rmd" class="external-link"><code>vignettes/Log_linear_times.Rmd</code></a></small>
      <div class="d-none name"><code>Log_linear_times.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="simulation-description">Simulation description<a class="anchor" aria-label="anchor" href="#simulation-description"></a>
</h2>
<p>Assume a population of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">K = 10^{5}</annotation></semantics></math>
individuals indexed by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>K</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>:=</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>K</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">k \in [K] := \{ 1, \dots, K\}</annotation></semantics></math>.
For person
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>,
we want to simulate the first occurrence of an event (e.g., emergence of
a tumor) over the age (time) interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>0</mn></mrow></msub><mo>,</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[T_{k0}, T_{k1})</annotation></semantics></math>.
For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mrow><mi>k</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">T_{k0}</annotation></semantics></math>
may be the age in years when person
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
enters the simulation, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">T_{k1}</annotation></semantics></math>
the age in years when that person dies from non-cancer causes. (In
practice,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">T_{k1}</annotation></semantics></math>
would be obtained by separate point process.) Only some people will
develop clinical cancer over their simulated lifetime.</p>
<p>To fix a simulation scenario, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>=</mo><mn>40</mn></mrow><annotation encoding="application/x-tex">a_k = 40</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>∼</mo><mi>U</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>50</mn><mo>,</mo><mn>100</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b_k \sim U(50 , 100)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U()</annotation></semantics></math>
is the uniform distribution.</p>
<p>We use the log-linear intensity function</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>e</mi><mrow><msub><mi>α</mi><mi>k</mi></msub><mo>+</mo><msub><mi>β</mi><mi>k</mi></msub><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\lambda_k(t) = e^{\alpha_k + \beta_k t}</annotation></semantics></math>,</p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is age in years. The parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>k</mi></msub><mo>,</mo><msub><mi>β</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_k, \beta_k</annotation></semantics></math>
are random over the individuals in the population with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>k</mi></msub><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mn>4</mn><mo>,</mo><mn>0.5</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\alpha_k \sim N(-4, 0.5)</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>k</mi></msub><mo>∼</mo><msub><mi>N</mi><mrow><mn>0</mn><mo>+</mo></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.03</mn><mo>,</mo><mn>0.003</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\beta_k \sim N_{0+}(0.03, 0.003)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">N()</annotation></semantics></math>
is a normal distribution and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mn>0</mn><mo>+</mo></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">N_{0+}()</annotation></semantics></math>
is a truncated normal distribution with support
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>∞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0, \infty)</annotation></semantics></math>.</p>
</div>
<div class="section level2">
<h2 id="overview-of-sampling-methods-described-here">Overview of sampling methods described here<a class="anchor" aria-label="anchor" href="#overview-of-sampling-methods-described-here"></a>
</h2>
<p>We will use three methods:</p>
<ol style="list-style-type: decimal">
<li><p>Simulate one person at a time looping over persons. The fastest
way to do this is to use a special case function in the
<code>nhppp</code> package that samples from log-linear intensity
functions in a non-vectorized fashion. Yet this will be slowest
approach.</p></li>
<li><p>Simulate all persons in a vectorized way using only the intensity
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda(t)</annotation></semantics></math>.
When you only know
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda(t)</annotation></semantics></math><code>nhppp</code> uses the thinning algorithm. It is a very flexible
approach because it does not require a lot of information – just
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda(t)</annotation></semantics></math>.
This will by much faster than the first option, but not as fast as the
third option.</p></li>
<li><p>Simulate all persons in a vectorized way using the cumulative
intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda(t)</annotation></semantics></math>
and its inverse
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda^{-1}(z)</annotation></semantics></math>,
which are defined below. When you have analytic expressions for these
objects, you get the fastest sampling in the <code>nhppp</code> package.
Then the package can use the <code>inversion</code> or the
<code>order statistics</code> algorithms which are more
efficient.</p></li>
</ol>
</div>
<div class="section level2">
<h2 id="setup">Setup<a class="anchor" aria-label="anchor" href="#setup"></a>
</h2>
<p>We will use <code>data.table</code>s – but the same analysis should
be obvious in base <code>R</code>. We will use functions from three more
packages, without loading them: the <code>truncnorm</code> package is
only needed for the truncated normal distribution. The
<code>tictoc()</code> package will be used for a simple time comparison
between the different ways one can simulate this problem. The
<code>stats</code> package is used to generate normally and uniformly
distributed samples.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-datatable.com" class="external-link">data.table</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://bladder-ca.github.io/nhppp/">nhppp</a></span><span class="op">)</span></span></code></pre></div>
<p>Setup <code>pop</code>, the population <code>data.table</code>. The
person specific parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>k</mi></msub><mo>,</mo><msub><mi>β</mi><mi>k</mi></msub><mo>,</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\alpha_k, \beta_k, T_{k0}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">T_{k1}</annotation></semantics></math>
are variables in <code>pop</code>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pop</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/setDT.html" class="external-link">setDT</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    id <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">K</span>,</span>
<span>    alpha <span class="op">=</span> <span class="fu">stats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">K</span>, mean <span class="op">=</span> <span class="op">-</span><span class="fl">4</span>, sd <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>    beta <span class="op">=</span> <span class="fu">truncnorm</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/truncnorm/man/dtruncnorm.html" class="external-link">rtruncnorm</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">K</span>, mean <span class="op">=</span> <span class="fl">0.03</span>, sd <span class="op">=</span> <span class="fl">0.003</span>, a <span class="op">=</span> <span class="fl">0</span>, b <span class="op">=</span> <span class="cn">Inf</span><span class="op">)</span>,</span>
<span>    T0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">40</span>, <span class="va">K</span><span class="op">)</span>,</span>
<span>    T1 <span class="op">=</span> <span class="fu">stats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">K</span>, min <span class="op">=</span> <span class="fl">50</span>, max <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/setkey.html" class="external-link">setindex</a></span><span class="op">(</span><span class="va">pop</span>, <span class="va">id</span><span class="op">)</span></span>
<span><span class="va">pop</span></span>
<span><span class="co">#&gt; Index: &lt;id&gt;</span></span>
<span><span class="co">#&gt;             id     alpha       beta    T0       T1</span></span>
<span><span class="co">#&gt;          &lt;int&gt;     &lt;num&gt;      &lt;num&gt; &lt;num&gt;    &lt;num&gt;</span></span>
<span><span class="co">#&gt;      1:      1 -4.318439 0.02914304    40 74.23810</span></span>
<span><span class="co">#&gt;      2:      2 -4.200092 0.03218084    40 62.26187</span></span>
<span><span class="co">#&gt;      3:      3 -4.250369 0.02916144    40 81.29045</span></span>
<span><span class="co">#&gt;      4:      4 -4.374602 0.02269157    40 94.50129</span></span>
<span><span class="co">#&gt;      5:      5 -4.075769 0.02973159    40 67.73704</span></span>
<span><span class="co">#&gt;     ---                                           </span></span>
<span><span class="co">#&gt;  99996:  99996 -4.113622 0.03196925    40 71.34211</span></span>
<span><span class="co">#&gt;  99997:  99997 -5.111481 0.02665030    40 84.46180</span></span>
<span><span class="co">#&gt;  99998:  99998 -3.628798 0.02907565    40 87.67655</span></span>
<span><span class="co">#&gt;  99999:  99999 -4.438333 0.03027740    40 99.96851</span></span>
<span><span class="co">#&gt; 100000: 100000 -3.483592 0.02673899    40 57.45794</span></span></code></pre></div>
<div class="section level3">
<h3 id="intensity-cumulative-intensity-and-inverse-cumulative-intensity-functions">Intensity, cumulative intensity, and inverse cumulative intensity
functions<a class="anchor" aria-label="anchor" href="#intensity-cumulative-intensity-and-inverse-cumulative-intensity-functions"></a>
</h3>
<p>Define some bespoke functions for the different simulation approaches
below. The trick is to define functions so that they work in a
vectorized form. For an example, take a look at the intensity function
below. The other functions have the same bahavior.</p>
<div class="section level4">
<h4 id="intensity-function-lambda">Intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda()</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#intensity-function-lambda"></a>
</h4>
<p>Define a vectorized form of the intensity function.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">l</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t</span>, <span class="va">alpha</span> <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">alpha</span>, <span class="va">beta</span> <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">beta</span>, <span class="va">...</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">alpha</span> <span class="op">+</span> <span class="va">beta</span> <span class="op">*</span> <span class="va">t</span><span class="op">)</span></span></code></pre></div>
<p>Arguments <code>alpha</code> and <code>beta</code> can be scalars or
vectors (or column matrices). Argument <code>t</code> can be a scalar, a
vector of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
ages (times), or a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">K \times s</annotation></semantics></math>
matrix. See some examples of the behavior of the vectorized function.
The ellipses (<code>...</code>) allow <code>l()</code> to ignore extra
arguments without breaking the execution of the script. While we won’t
do that on purpose, some sampling functions in the <code>nhppp</code>
package that take function arguments need the ability to pass optional
extraneous arguments.</p>
<p>Scalar arguments, evaluated at <code>t = 45</code></p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">l</span><span class="op">(</span>t <span class="op">=</span> <span class="fl">45</span>, alpha <span class="op">=</span> <span class="op">-</span><span class="fl">4</span>, beta <span class="op">=</span> <span class="fl">0.03</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.07065121</span></span></code></pre></div>
<p>Scalar arguments, evaluated at <code>t = 45:50</code> (vector) or as
a column matrix The function returns results in the format of the
<code>t</code> argument.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">l</span><span class="op">(</span>t <span class="op">=</span> <span class="fl">45</span><span class="op">:</span><span class="fl">50</span>, alpha <span class="op">=</span> <span class="op">-</span><span class="fl">4</span>, beta <span class="op">=</span> <span class="fl">0.03</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.07065121 0.07280286 0.07502004 0.07730474 0.07965902 0.08208500</span></span>
<span></span>
<span><span class="fu">l</span><span class="op">(</span>t <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">45</span><span class="op">:</span><span class="fl">50</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>, alpha <span class="op">=</span> <span class="op">-</span><span class="fl">4</span>, beta <span class="op">=</span> <span class="fl">0.03</span><span class="op">)</span></span>
<span><span class="co">#&gt;            [,1]</span></span>
<span><span class="co">#&gt; [1,] 0.07065121</span></span>
<span><span class="co">#&gt; [2,] 0.07280286</span></span>
<span><span class="co">#&gt; [3,] 0.07502004</span></span>
<span><span class="co">#&gt; [4,] 0.07730474</span></span>
<span><span class="co">#&gt; [5,] 0.07965902</span></span>
<span><span class="co">#&gt; [6,] 0.08208500</span></span></code></pre></div>
<p>Vector arguments, using the first 5 people and evaluating all people
at <code>t = 45</code></p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">l</span><span class="op">(</span>t <span class="op">=</span> <span class="fl">45</span>, alpha <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, beta <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">beta</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.04943966 0.06380303 0.05296605 0.03496243 0.06470944</span></span></code></pre></div>
<p>Matrix arguments are convenient: the rows are people and the columns
are the ages (times) – and they can differ across persons. For the first
5 people, we evaluate a different age for each person. The results are
returned in a matrix format.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">l</span><span class="op">(</span>t <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">45</span>, <span class="fl">50</span>, <span class="fl">45</span>, <span class="fl">47.4</span>, <span class="fl">30</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>, alpha <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, beta <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">beta</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;            [,1]</span></span>
<span><span class="co">#&gt; [1,] 0.04943966</span></span>
<span><span class="co">#&gt; [2,] 0.07494128</span></span>
<span><span class="co">#&gt; [3,] 0.05296605</span></span>
<span><span class="co">#&gt; [4,] 0.03691928</span></span>
<span><span class="co">#&gt; [5,] 0.04142702</span></span></code></pre></div>
<p>For the first 5 people, we evaluate three different ages for each
person. We arrange a <code>t_mat</code> matrix of ages (times) with
people in the rows and ages (times) for each person in the columns. The
results are returned in a matrix format.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>  <span class="fl">45</span>, <span class="fl">50</span>, <span class="fl">45</span>, <span class="fl">47.4</span>, <span class="fl">30</span>,</span>
<span>  <span class="fl">45.1</span>, <span class="fl">50.1</span>, <span class="fl">45.5</span>, <span class="fl">47.8</span>, <span class="fl">38</span>,</span>
<span>  <span class="fl">48</span>, <span class="fl">52.7</span>, <span class="fl">60.1</span>, <span class="fl">70.1</span>, <span class="fl">99.9</span></span>
<span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">3</span>, byrow <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">t_mat</span></span>
<span><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span><span class="co">#&gt; [1,] 45.0 50.0 45.0</span></span>
<span><span class="co">#&gt; [2,] 47.4 30.0 45.1</span></span>
<span><span class="co">#&gt; [3,] 50.1 45.5 47.8</span></span>
<span><span class="co">#&gt; [4,] 38.0 48.0 52.7</span></span>
<span><span class="co">#&gt; [5,] 60.1 70.1 99.9</span></span>
<span></span>
<span><span class="fu">l</span><span class="op">(</span>t <span class="op">=</span> <span class="va">t_mat</span>, alpha <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, beta <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">beta</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;            [,1]       [,2]       [,3]</span></span>
<span><span class="co">#&gt; [1,] 0.04943966 0.05719509 0.04943966</span></span>
<span><span class="co">#&gt; [2,] 0.06892608 0.03937330 0.06400868</span></span>
<span><span class="co">#&gt; [3,] 0.06145926 0.05374399 0.05747231</span></span>
<span><span class="co">#&gt; [4,] 0.02982757 0.03742537 0.04163741</span></span>
<span><span class="co">#&gt; [5,] 0.10137780 0.13647889 0.33101750</span></span></code></pre></div>
<p>The defaults for the <code>alpha</code> and <code>beta</code>
arguments of the <code>l()</code> functions are the respective columns
of the whole population. We can then evaluate the intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda()</annotation></semantics></math>
for the whole population passing only the <code>t</code> argument.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">45</span>, <span class="fl">50</span>, <span class="fl">55</span><span class="op">)</span>, each <span class="op">=</span> <span class="va">K</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">3</span>, byrow <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu">l</span><span class="op">(</span>t <span class="op">=</span> <span class="va">t_mat</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;            [,1]       [,2]       [,3]</span></span>
<span><span class="co">#&gt; [1,] 0.04943966 0.04943966 0.04943966</span></span>
<span><span class="co">#&gt; [2,] 0.06380303 0.06380303 0.06380303</span></span>
<span><span class="co">#&gt; [3,] 0.05296605 0.05296605 0.05296605</span></span>
<span><span class="co">#&gt; [4,] 0.03496243 0.03496243 0.03496243</span></span>
<span><span class="co">#&gt; [5,] 0.06470944 0.06470944 0.06470944</span></span>
<span><span class="co">#&gt; [6,] 0.08214702 0.08214702 0.08214702</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="cumulative-intensity-function-lambdat">Cumulative intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda(t)</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#cumulative-intensity-function-lambdat"></a>
</h4>
<p>The cumulative intensity function is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∫</mo><mi>a</mi><mi>t</mi></msubsup><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.222em"></mspace><mtext mathvariant="normal">d</mtext><mi>s</mi></mrow><annotation encoding="application/x-tex">\Lambda(a, t) = \int_a^t \lambda(s) \ \textrm{d}s</annotation></semantics></math>.
It does not matter what we choose for the lower limit of integration in
the definition of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Λ</mi><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>.
The lower limit cancels out in the mathematics of the sampling
algorithms. Thus we are free to use any lower limit (say 0) for any
antiderivative of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda()</annotation></semantics></math>
that is convenient (for any integration constant).</p>
<p>With a slight abuse of notation, define 0 as the lower integration
limit and write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>t</mi></msubsup><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.222em"></mspace><mtext mathvariant="normal">d</mtext><mi>s</mi></mrow><annotation encoding="application/x-tex">{\Lambda(t) := \Lambda(0, t) = \int_0^t \lambda(s) \ \textrm{d}s}</annotation></semantics></math>.
For the log-linear intensity in this example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mi>β</mi></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>α</mi><mo>+</mo><mi>β</mi><mi>t</mi></mrow></msup><mo>−</mo><msup><mi>e</mi><mi>α</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda(t) = \frac{1}{\beta} (e^{\alpha + \beta t} - e^\alpha)</annotation></semantics></math>.</p>
<p>The vectorized version of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Λ</mi><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>
for our example is</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">L</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t</span>, <span class="va">alpha</span> <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">alpha</span>, <span class="va">beta</span> <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">beta</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">alpha</span> <span class="op">+</span> <span class="va">beta</span> <span class="op">*</span> <span class="va">t</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">beta</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="inverse-cumulative-intensity-function-lambda-1z">Inverse cumulative intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda^{-1}(z)</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#inverse-cumulative-intensity-function-lambda-1z"></a>
</h4>
<p>By its construction,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Λ</mi><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>
is a strictly positive monotone function in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
and thus invertible. The inverse of the cumulative intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\Lambda^{-1}</annotation></semantics></math>
is defined as the function that recovers the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
when you pass it the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda(t)</annotation></semantics></math>.
The definition is that it satisfies
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>=</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">{\Lambda^{-1} \big ( \Lambda(t) \big ) = t}</annotation></semantics></math>.
In our example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mi>z</mi><mo>+</mo><msup><mi>e</mi><mi>α</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>α</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mi>/</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\Lambda^{-1}(z) = \big(\log(\beta z + e^\alpha) - \alpha\big)/\beta</annotation></semantics></math>,
which is easily derived from the formula of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda(t)</annotation></semantics></math>.</p>
<p>The vectorized implementation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\Lambda^{-1}</annotation></semantics></math>
for our example is</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Li</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">z</span>, <span class="va">alpha</span> <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">alpha</span>, <span class="va">beta</span> <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">beta</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">beta</span> <span class="op">*</span> <span class="va">z</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">)</span><span class="op">)</span> <span class="op">-</span> <span class="va">alpha</span><span class="op">)</span> <span class="op">/</span> <span class="va">beta</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="method-1-non-vectorized-sampling-with-nhpppdraw_sc_loglinear">Method 1: non-vectorized sampling with
<code>nhppp::draw_sc_loglinear()</code><a class="anchor" aria-label="anchor" href="#method-1-non-vectorized-sampling-with-nhpppdraw_sc_loglinear"></a>
</h2>
<p>The <code>nhppp</code> package function
<code><a href="../reference/draw_sc_loglinear.html">draw_sc_loglinear()</a></code> draws times from log-linear densities
for each person at a time. This is slower than the other methods, but
can be practical even for sizeable simulations that will be run once
(e.g., for statistical simulation analyses) or when you develop
code.</p>
<p>It’s arguments <code>intercept</code>, <code>slope</code> have the
same name as the parameters in our log-linear intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.
The <code>t_min</code>, <code>t_max</code> arguments ask for the bounds
of the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>0</mn></mrow></msub><mo>,</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[T_{k0}, T_{k1})</annotation></semantics></math>.
The argument <code>atmost1</code> asks only for the first time. This
special case function uses a bespoke inversion algorithm; it’s as fast
as we can do without vectorization.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tictoc</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tictoc/man/tic.html" class="external-link">tic</a></span><span class="op">(</span><span class="st">"Method 1 (nonvectorized)"</span><span class="op">)</span></span>
<span><span class="va">t_nonvec_special_case</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">K</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">k</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">K</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">t1</span> <span class="op">&lt;-</span> <span class="fu">nhppp</span><span class="fu">::</span><span class="fu"><a href="../reference/draw_sc_loglinear.html">draw_sc_loglinear</a></span><span class="op">(</span></span>
<span>    intercept <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">alpha</span><span class="op">[</span><span class="va">k</span><span class="op">]</span>,</span>
<span>    slope <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">beta</span><span class="op">[</span><span class="va">k</span><span class="op">]</span>,</span>
<span>    t_min <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">T0</span><span class="op">[</span><span class="va">k</span><span class="op">]</span>,</span>
<span>    t_max <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">T1</span><span class="op">[</span><span class="va">k</span><span class="op">]</span>,</span>
<span>    atmost1 <span class="op">=</span> <span class="cn">TRUE</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">t1</span><span class="op">)</span> <span class="op">!=</span> <span class="fl">0</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">t_nonvec_special_case</span><span class="op">[</span><span class="va">k</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">t1</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="fu">tictoc</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tictoc/man/tic.html" class="external-link">toc</a></span><span class="op">(</span>log <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Method 1 (nonvectorized): 1.516 sec elapsed</span></span>
<span><span class="va">pop</span><span class="op">[</span>, <span class="va">t_nonvec_special_case</span> <span class="op">:=</span> <span class="va">t_nonvec_special_case</span><span class="op">]</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="method-2-vectorized-sampling-using-only-lambda">Method 2: Vectorized sampling using only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda()</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#method-2-vectorized-sampling-using-only-lambda"></a>
</h2>
<p>When you only know the intensity function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>,
<code>nhppp</code> employs a thinning algorithm.</p>
<p>One of the items needed for the thinning algorithm is a piecewise
constant majorizer function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mo>*</mo></msub><annotation encoding="application/x-tex">\lambda_*</annotation></semantics></math>
such that:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mo>*</mo></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mo>=</mo><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_*(t) &gt;= \lambda(t)</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
of interest.</p>
<p>The <code><a href="../reference/vdraw_intensity.html">nhppp::vdraw_intensity</a></code> function assumes that you
will provide the majorizer function as a matrix
(<code>lambda_maj_matrix</code>). To create this matrix, split the
simulation time (here, from age 40 to age 100) in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
equal-length intervals. For person
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>,
the element <code>lambda_maj_matrix[k, m]</code> records a supremum of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\lambda_k</annotation></semantics></math>
over the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>-th
interval. Any supremum will do – but the algorithm is most efficient
when you give it the least upper bound – practically, the maximum of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda(t)</annotation></semantics></math>
over all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in the interval. For monotone intensity functions, such as the function
in the example, the maximum is at one of the interval’s bounds. It will
be at the left bound, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
is decreasing, and at the right bound, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
is increasing.</p>
<p>There is a helper function in <code>nhppp</code> that generates the
majorizer matrix automatically for monotone (and possibly discontinuous)
functions and for nonmonotone continuous Lipschitz functions (functions
whose maximum slope is bounded). Even if your case is more complex, you
should be able to find a supremum that works.</p>
<p>This code samples in a vectorized fashion when you know only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda()</annotation></semantics></math>.
It creates a majorizer matrix over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">M=5</annotation></semantics></math>
intervals. To let the software know which times correspond to each of
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
intervals it suffices to specify a start and stop time for each row of
the majorizer matrix with the <code>rate_matrix_t_min</code> and
<code>rate_matrix_t_max</code> options. The sampling intervals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>0</mn></mrow></msub><mo>,</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[T_{k0}, T_{k1})</annotation></semantics></math>for
each simulated person are a subset of the interval for which the
majorizer matrix is defined, and are specified with the
<code>t_min</code> and <code>t_max</code> options. (The
<code>atmostB</code> option can be useful to speed up the sampling and
minimize memory needs when one is interested in the first event only.
The smaller the value, the faster the algorithm but you have to check
that you have not specified it to be too small. In this example,
<code>atmostB = 5</code> is fine – it returns exact solutions; but we
have checked it [not shown]. If you do not want to mess with it, do not
use the option. The function may be already fast enough for your
needs).</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tictoc</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tictoc/man/tic.html" class="external-link">tic</a></span><span class="op">(</span><span class="st">"Method 2 (vectorized, thinning)"</span><span class="op">)</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">break_points</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq.int</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">40</span>, to <span class="op">=</span> <span class="fl">100</span>, length.out <span class="op">=</span> <span class="va">M</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">breaks_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="va">break_points</span>, each <span class="op">=</span> <span class="va">K</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="va">K</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lmaj_mat</span> <span class="op">&lt;-</span> <span class="fu">nhppp</span><span class="fu">::</span><span class="fu"><a href="../reference/get_step_majorizer.html">get_step_majorizer</a></span><span class="op">(</span></span>
<span>  fun <span class="op">=</span> <span class="va">l</span>,</span>
<span>  breaks <span class="op">=</span> <span class="va">breaks_mat</span>,</span>
<span>  is_monotone <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">pop</span><span class="op">[</span></span>
<span>  ,</span>
<span>  <span class="va">t_thinning</span> <span class="op">:=</span> <span class="fu">nhppp</span><span class="fu">::</span><span class="fu"><a href="../reference/vdraw_intensity.html">vdraw_intensity</a></span><span class="op">(</span></span>
<span>    lambda <span class="op">=</span> <span class="va">l</span>,</span>
<span>    lambda_maj_matrix <span class="op">=</span> <span class="va">lmaj_mat</span>,</span>
<span>    rate_matrix_t_min <span class="op">=</span> <span class="fl">40</span>,</span>
<span>    rate_matrix_t_max <span class="op">=</span> <span class="fl">100</span>,</span>
<span>    t_min <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">T0</span>,</span>
<span>    t_max <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">T1</span>,</span>
<span>    atmost1 <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    atmostB <span class="op">=</span> <span class="fl">5</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">]</span></span>
<span><span class="fu">tictoc</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tictoc/man/tic.html" class="external-link">toc</a></span><span class="op">(</span>log <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="co"># timer end</span></span>
<span><span class="co">#&gt; Method 2 (vectorized, thinning): 0.114 sec elapsed</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="method-3-vectorized-sampling-using-lambda-and-lambda-1">Method 3: Vectorized sampling using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda()</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda^{-1}()</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#method-3-vectorized-sampling-using-lambda-and-lambda-1"></a>
</h2>
<p>The most efficient sampling is possible when one knows
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda()</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Lambda^{-1}()</annotation></semantics></math>.
The <code>nhppp</code> package can sample in this case using the
<code><a href="../reference/vdraw_cumulative_intensity.html">vdraw_cumulative_intensity()</a></code> function. Here
<code>range_t</code> is a matrix with information on each person’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>0</mn></mrow></msub><mo>,</mo><msub><mi>T</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[T_{k0}, T_{k1})</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tictoc</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tictoc/man/tic.html" class="external-link">tic</a></span><span class="op">(</span><span class="st">"Method 3 (inversion)"</span><span class="op">)</span></span>
<span><span class="va">pop</span><span class="op">[</span></span>
<span>  ,</span>
<span>  <span class="va">t_inversion</span> <span class="op">:=</span> <span class="fu">nhppp</span><span class="fu">::</span><span class="fu"><a href="../reference/vdraw_cumulative_intensity.html">vdraw_cumulative_intensity</a></span><span class="op">(</span></span>
<span>    Lambda <span class="op">=</span> <span class="va">L</span>,</span>
<span>    Lambda_inv <span class="op">=</span> <span class="va">Li</span>,</span>
<span>    t_min <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">T0</span>,</span>
<span>    t_max <span class="op">=</span> <span class="va">pop</span><span class="op">$</span><span class="va">T1</span>,</span>
<span>    atmost1 <span class="op">=</span> <span class="cn">TRUE</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">]</span></span>
<span><span class="fu">tictoc</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tictoc/man/tic.html" class="external-link">toc</a></span><span class="op">(</span>log <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="co"># timer end</span></span>
<span><span class="co">#&gt; Method 3 (inversion): 0.016 sec elapsed</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="comparisons">Comparisons<a class="anchor" aria-label="anchor" href="#comparisons"></a>
</h2>
<div class="section level3">
<h3 id="simulation-time-costs">Simulation time-costs<a class="anchor" aria-label="anchor" href="#simulation-time-costs"></a>
</h3>
<p>The simulation time-costs that you see in this document depend on the
machine that rendered it. If you read this online, this machine is
probably some virtual server with minimal resources. If you installed
the package locally, it is probably the machine you are using to run
<code>R</code>.</p>
<ol style="list-style-type: decimal">
<li><p>Method 1 (nonvectorized): 1.516 sec elapsed. This is the slowest
approach – but still not bad for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>10</mn><mn>5</mn></msup><annotation encoding="application/x-tex">10^{5}</annotation></semantics></math>
samples!</p></li>
<li><p>Method 2 (vectorized, thinning): 0.114 sec elapsed. This approach
is many times faster that then first approach. It is very flexible – it
can accommodate very complex time varying intensity functions. You
almost always know
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
and can get its majorizer
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mo>*</mo></msub><annotation encoding="application/x-tex">\lambda_*</annotation></semantics></math>
easily and fast.</p></li>
<li><p>Method 3 (inversion): 0.016 sec elapsed. This approach is many
times faster that the second one, but requires implementations for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Λ</mi><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\Lambda^{-1}</annotation></semantics></math>.</p></li>
</ol>
</div>
<div class="section level3">
<h3 id="simulated-times">Simulated times<a class="anchor" aria-label="anchor" href="#simulated-times"></a>
</h3>
<p>All three methods sample correctly from the specified log-linear
process. There is no approximation at play.</p>
<p>The QQ plots compare the simulated times with the three methods. The
agreement is excellent over this population of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">K = 10^{5}</annotation></semantics></math>.
As
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
increases the agreement remains excellent (not shown here - try it for
yourself). The paper in the bibliography includes in-depth comparisons.
A set of QQ plots should suffice here.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/qqnorm.html" class="external-link">qqplot</a></span><span class="op">(</span><span class="va">pop</span><span class="op">$</span><span class="va">t_nonvec_special_case</span>, <span class="va">pop</span><span class="op">$</span><span class="va">t_thinning</span><span class="op">)</span></span></code></pre></div>
<p><img src="Log_linear_times_files/figure-html/qq-plots-1.png" alt="QQ plots comparing simulated times with the three methods. The QQ plots indicate excellent agreement." width="700"></p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/qqnorm.html" class="external-link">qqplot</a></span><span class="op">(</span><span class="va">pop</span><span class="op">$</span><span class="va">t_nonvec_special_case</span>, <span class="va">pop</span><span class="op">$</span><span class="va">t_inversion</span><span class="op">)</span></span></code></pre></div>
<p><img src="Log_linear_times_files/figure-html/qq-plots-2.png" alt="QQ plots comparing simulated times with the three methods. The QQ plots indicate excellent agreement." width="700"></p>
</div>
</div>
<div class="section level2">
<h2 id="acknowledgments">Acknowledgments<a class="anchor" aria-label="anchor" href="#acknowledgments"></a>
</h2>
<p>Thanks to Carolyn Rutter and Hui Hsuan Chan for providing the
numerical example in this vignette.</p>
</div>
<div class="section level2">
<h2 id="bibliography">Bibliography<a class="anchor" aria-label="anchor" href="#bibliography"></a>
</h2>
<p>Trikalinos TA, Sereda Y. <em>nhppp: Simulating Nonhomogeneous Poisson
Point Processes in R</em>. arXiv preprint arXiv:2402.00358. 2024 Feb
1.</p>
<p>Since the publication of the paper, the syntax and options of the
<code>nhppp</code> package have evolved. To reproduce the code in the
paper, you have to install the version of <code>nhppp</code> used in the
paper. Alternatively, take a look at the vignettes, which are written to
work with the current package.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Thomas Trikalinos, Yuliia Sereda.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
